<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FPS 배틀로얄</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Roboto', sans-serif;
            background: #2c3e50;
            overflow: hidden;
            cursor: crosshair;
        }
        
        #gameContainer {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        
        canvas {
            display: block;
            background: #87CEEB;
        }
        
        #hud {
            position: absolute;
            bottom: 20px;
            left: 20px;
            right: 20px;
            color: white;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
        }
        
        #healthBar, #armorBar {
            width: 200px;
            height: 20px;
            background: rgba(0,0,0,0.5);
            border: 2px solid #fff;
            margin: 5px 0;
            position: relative;
        }
        
        #healthFill {
            height: 100%;
            background: linear-gradient(90deg, #ff4444, #ff6666);
            width: 100%;
            transition: width 0.3s;
        }
        
        #armorFill {
            height: 100%;
            background: linear-gradient(90deg, #4444ff, #6666ff);
            width: 100%;
            transition: width 0.3s;
        }
        
        #weaponInfo {
            position: absolute;
            bottom: 20px;
            right: 20px;
            color: white;
            text-align: right;
            font-size: 18px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
        }
        
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            pointer-events: none;
        }
        
        .crosshair-line {
            position: absolute;
            background: #fff;
            box-shadow: 0 0 4px rgba(0,0,0,0.8);
        }
        
        .crosshair-h {
            width: 20px;
            height: 2px;
            top: 9px;
        }
        
        .crosshair-v {
            width: 2px;
            height: 20px;
            left: 9px;
        }
        
        #damageIndicator {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
            border: 10px solid transparent;
            transition: border-color 0.3s;
        }
        
        .damage-flash {
            border-color: rgba(255, 0, 0, 0.5) !important;
        }
        
        #gameOver {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 30px;
            border-radius: 10px;
            text-align: center;
            display: none;
        }
        
        #minimap {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 150px;
            height: 150px;
            background: rgba(0,0,0,0.7);
            border: 2px solid #fff;
            border-radius: 5px;
        }
        
        #instructions {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            font-size: 12px;
            background: rgba(0,0,0,0.5);
            padding: 10px;
            border-radius: 5px;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        
        <div id="crosshair">
            <div class="crosshair-line crosshair-h"></div>
            <div class="crosshair-line crosshair-v"></div>
        </div>
        
        <div id="damageIndicator"></div>
        
        <div id="hud">
            <div>체력: <span id="healthText">100</span>%</div>
            <div id="healthBar"><div id="healthFill"></div></div>
            <div>방어구: <span id="armorText">0</span>%</div>
            <div id="armorBar"><div id="armorFill"></div></div>
        </div>
        
        <div id="weaponInfo">
            <div id="weaponName">맨손</div>
            <div id="ammoCount">-/-</div>
        </div>
        
        <canvas id="minimap"></canvas>
        
        <div id="instructions">
            WASD: 이동 | Shift: 달리기 | Space: 사격 | R: 재장전<br>
            E: 정밀조준 | F: 아이템 획득<br>
            1,2,3: 무기 선택 | 4: 수류탄 | Q: 무기 버리기 | 생존자: <span id="aliveCount">16</span>명
        </div>
        
        <div id="gameOver">
            <h2 id="gameResult">게임 오버</h2>
            <p id="finalRank">순위: -</p>
            <button onclick="location.reload()">다시 시작</button>
        </div>
    </div>

    <script>
        // 게임 설정
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const minimapCanvas = document.getElementById('minimap');
        const minimapCtx = minimapCanvas.getContext('2d');
        
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        minimapCanvas.width = 150;
        minimapCanvas.height = 150;
        
        // 게임 상태
        let gameState = 'playing';
        let camera = { x: 0, y: 0 };
        let zoom = 1;
        let isAiming = false;
        
        // 맵 크기
        const MAP_SIZE = 4000;
        
        // 플레이어
        let player = {
            x: Math.random() * MAP_SIZE,
            y: Math.random() * MAP_SIZE,
            angle: 0,
            health: 100,
            armor: 0,
            currentWeapon: 'fist',
            weapons: { fist: { name: '주먹', damage: 15, ammo: -1, maxAmmo: -1, fireRate: 500, range: 80, autoFire: false } },
            inventory: [],
            speed: 3,
            size: 15,
            grenades: 0,
            kills: 0,
            lastShot: 0,
            isAutoFiring: false,
            isRunning: false
        };
        
        // 키 입력
        let keys = {};
        let mouseX = 0, mouseY = 0;
        let mousePressed = false;
        
        // 게임 객체들
        let bullets = [];
        let items = [];
        let enemies = [];
        let obstacles = [];
        let particles = [];
        let grenades = [];
        let houses = [];
        
        // 무기 정의
        const weapons = {
            ar: { name: 'AR', damage: 35, ammo: 30, maxAmmo: 30, fireRate: 120, range: 400, ammoType: 'rifle', autoFire: true },
            shotgun: { name: '샷건', damage: 60, ammo: 8, maxAmmo: 8, fireRate: 800, range: 150, ammoType: 'shotgun', autoFire: false },
            smg: { name: 'SMG', damage: 25, ammo: 25, maxAmmo: 25, fireRate: 80, range: 250, ammoType: 'smg', autoFire: true },
            sr: { name: 'SR', damage: 90, ammo: 5, maxAmmo: 5, fireRate: 1200, range: 800, ammoType: 'sniper', autoFire: false, zoomLevel: 2.0 }
        };
        
        // 아이템 정의
        const itemTypes = {
            weapon: { color: '#FFD700', size: 10 },
            ammo: { color: '#FFA500', size: 8 },
            armor: { color: '#4169E1', size: 10 },
            medkit: { color: '#32CD32', size: 10 },
            bandage: { color: '#90EE90', size: 8 },
            grenade: { color: '#8B0000', size: 6 }
        };
        
        // 초기화
        function init() {
            generateMap();
            spawnEnemies();
            spawnItems();
            updateHUD();
            gameLoop();
        }
        
        // 맵 생성
        function generateMap() {
            // 집 생성 (장식용, 장애물 없음)
            for (let i = 0; i < 20; i++) {
                const houseX = Math.random() * (MAP_SIZE - 200) + 100;
                const houseY = Math.random() * (MAP_SIZE - 200) + 100;
                const houseWidth = 80 + Math.random() * 40;
                const houseHeight = 80 + Math.random() * 40;
                
                houses.push({
                    x: houseX,
                    y: houseY,
                    width: houseWidth,
                    height: houseHeight,
                    doorX: houseX + houseWidth / 2 - 10,
                    doorY: houseY + houseHeight,
                    doorWidth: 20,
                    doorHeight: 5
                });
            }
            
            // 나무 생성
            for (let i = 0; i < 200; i++) {
                let treeX, treeY;
                let attempts = 0;
                
                do {
                    treeX = Math.random() * (MAP_SIZE - 40);
                    treeY = Math.random() * (MAP_SIZE - 40);
                    attempts++;
                } while (attempts < 50 && isNearHouse(treeX, treeY, 50));
                
                obstacles.push({
                    x: treeX,
                    y: treeY,
                    width: 20 + Math.random() * 20,
                    height: 20 + Math.random() * 20,
                    type: 'tree',
                    color: '#228B22'
                });
            }
            
            // 바위 생성
            for (let i = 0; i < 100; i++) {
                let rockX, rockY;
                let attempts = 0;
                
                do {
                    rockX = Math.random() * (MAP_SIZE - 60);
                    rockY = Math.random() * (MAP_SIZE - 60);
                    attempts++;
                } while (attempts < 50 && isNearHouse(rockX, rockY, 50));
                
                obstacles.push({
                    x: rockX,
                    y: rockY,
                    width: 30 + Math.random() * 30,
                    height: 30 + Math.random() * 30,
                    type: 'rock',
                    color: '#696969'
                });
            }
        }
        
        // 집 근처인지 확인
        function isNearHouse(x, y, distance) {
            for (let house of houses) {
                if (x > house.x - distance && x < house.x + house.width + distance &&
                    y > house.y - distance && y < house.y + house.height + distance) {
                    return true;
                }
            }
            return false;
        }
        
        // 적 스폰
        function spawnEnemies() {
            for (let i = 0; i < 15; i++) {
                let spawnX, spawnY;
                let attempts = 0;
                
                // 장애물과 겹치지 않는 위치 찾기
                do {
                    spawnX = Math.random() * (MAP_SIZE - 30) + 15;
                    spawnY = Math.random() * (MAP_SIZE - 30) + 15;
                    attempts++;
                } while (attempts < 50 && isPositionBlocked(spawnX, spawnY, 15));
                
                enemies.push({
                    x: spawnX,
                    y: spawnY,
                    angle: Math.random() * Math.PI * 2,
                    health: 100,
                    armor: 0,
                    weapon: null,
                    speed: 1.5 + Math.random() * 1,
                    size: 15,
                    lastShot: 0,
                    target: null,
                    grenades: Math.random() < 0.3 ? 1 + Math.floor(Math.random() * 2) : 0,
                    ai: {
                        state: 'patrol',
                        lastStateChange: 0,
                        patrolTarget: { x: Math.random() * MAP_SIZE, y: Math.random() * MAP_SIZE },
                        farmingTarget: null,
                        fleeTimer: 0,
                        aggressionLevel: Math.random() * 0.8 + 0.2, // 0.2 ~ 1.0
                        lastPlayerSeen: 0,
                        searchTimer: 0,
                        moveTimer: 0,
                        lastGrenadeThrow: 0
                    }
                });
            }
        }
        
        // 아이템 스폰
        function spawnItems() {
            // 집 안에 아이템 스폰 (70%)
            houses.forEach(house => {
                const itemsInHouse = 3 + Math.floor(Math.random() * 4);
                
                for (let i = 0; i < itemsInHouse; i++) {
                    const spawnX = house.x + 15 + Math.random() * (house.width - 30);
                    const spawnY = house.y + 15 + Math.random() * (house.height - 30);
                    
                    const types = ['weapon', 'ammo', 'armor', 'medkit', 'bandage', 'grenade'];
                    const weights = [0.25, 0.3, 0.15, 0.1, 0.15, 0.05];
                    const type = weightedRandom(types, weights);
                    
                    let data = {};
                    if (type === 'weapon') {
                        const weaponTypes = Object.keys(weapons);
                        data.weaponType = weaponTypes[Math.floor(Math.random() * weaponTypes.length)];
                    } else if (type === 'ammo') {
                        const ammoTypes = ['rifle', 'shotgun', 'smg', 'sniper'];
                        data.ammoType = ammoTypes[Math.floor(Math.random() * ammoTypes.length)];
                        data.amount = 30;
                    } else if (type === 'armor') {
                        data.amount = 25 + Math.random() * 50;
                    } else if (type === 'medkit') {
                        data.amount = 75;
                        data.healTime = 3000;
                    } else if (type === 'bandage') {
                        data.amount = 25;
                        data.healTime = 1000;
                    } else if (type === 'grenade') {
                        data.amount = 1 + Math.floor(Math.random() * 2);
                    }
                    
                    items.push({
                        x: spawnX,
                        y: spawnY,
                        type: type,
                        data: data,
                        ...itemTypes[type]
                    });
                }
            });
            
            // 야외에 아이템 스폰 (30%)
            for (let i = 0; i < 50; i++) {
                let spawnX, spawnY;
                let attempts = 0;
                
                do {
                    spawnX = Math.random() * (MAP_SIZE - 40) + 20;
                    spawnY = Math.random() * (MAP_SIZE - 40) + 20;
                    attempts++;
                } while (attempts < 50 && (isPositionBlocked(spawnX, spawnY, 15) || isNearHouse(spawnX, spawnY, 20)));
                
                const types = ['weapon', 'ammo', 'armor', 'medkit', 'bandage'];
                const type = types[Math.floor(Math.random() * types.length)];
                
                let data = {};
                if (type === 'weapon') {
                    const weaponTypes = Object.keys(weapons);
                    data.weaponType = weaponTypes[Math.floor(Math.random() * weaponTypes.length)];
                } else if (type === 'ammo') {
                    const ammoTypes = ['rifle', 'shotgun', 'smg', 'sniper'];
                    data.ammoType = ammoTypes[Math.floor(Math.random() * ammoTypes.length)];
                    data.amount = 30;
                } else if (type === 'armor') {
                    data.amount = 25 + Math.random() * 50;
                } else if (type === 'medkit') {
                    data.amount = 75;
                    data.healTime = 3000;
                } else if (type === 'bandage') {
                    data.amount = 25;
                    data.healTime = 1000;
                }
                
                items.push({
                    x: spawnX,
                    y: spawnY,
                    type: type,
                    data: data,
                    ...itemTypes[type]
                });
            }
        }
        
        // 가중치 기반 랜덤 선택
        function weightedRandom(items, weights) {
            const totalWeight = weights.reduce((sum, weight) => sum + weight, 0);
            let random = Math.random() * totalWeight;
            
            for (let i = 0; i < items.length; i++) {
                random -= weights[i];
                if (random <= 0) {
                    return items[i];
                }
            }
            return items[items.length - 1];
        }
        
        // 충돌 감지
        function checkCollision(obj1, obj2) {
            return obj1.x < obj2.x + obj2.width &&
                   obj1.x + obj1.size > obj2.x &&
                   obj1.y < obj2.y + obj2.height &&
                   obj1.y + obj1.size > obj2.y;
        }
        
        // 위치가 장애물에 막혀있는지 확인
        function isPositionBlocked(x, y, size) {
            for (let obstacle of obstacles) {
                if (x - size < obstacle.x + obstacle.width &&
                    x + size > obstacle.x &&
                    y - size < obstacle.y + obstacle.height &&
                    y + size > obstacle.y) {
                    return true;
                }
            }
            return false;
        }
        
        // 이동 가능한 위치인지 확인
        function canMoveTo(x, y, size) {
            // 맵 경계 체크
            if (x - size < 0 || x + size > MAP_SIZE || y - size < 0 || y + size > MAP_SIZE) {
                return false;
            }
            
            // 장애물 체크
            return !isPositionBlocked(x, y, size);
        }
        
        // 거리 계산
        function distance(obj1, obj2) {
            return Math.sqrt((obj1.x - obj2.x) ** 2 + (obj1.y - obj2.y) ** 2);
        }
        
        // 각도 계산
        function angleTo(from, to) {
            return Math.atan2(to.y - from.y, to.x - from.x);
        }
        
        // 총알 발사
        function shoot(shooter, targetX, targetY) {
            // 수류탄 투척 처리
            if (shooter === player && shooter.currentWeapon === 'grenade') {
                throwGrenade(shooter, targetX, targetY);
                return;
            }
            
            let weapon;
            if (shooter === player) {
                weapon = shooter.weapons[shooter.currentWeapon];
                if (!weapon || Date.now() - shooter.lastShot < weapon.fireRate) return;
            } else {
                if (!shooter.weapon) return;
                weapon = weapons[shooter.weapon];
                if (!weapon || Date.now() - shooter.lastShot < weapon.fireRate) return;
            }
            
            if (weapon.ammo !== -1 && weapon.ammo <= 0) return;
            
            if (weapon.ammo !== -1) weapon.ammo--;
            
            if (shooter === player) {
                shooter.lastShot = Date.now();
            } else {
                shooter.lastShot = Date.now();
            }
            
            const angle = Math.atan2(targetY - shooter.y, targetX - shooter.x);
            
            if (shooter.currentWeapon === 'shotgun' || shooter.weapon === 'shotgun') {
                // 샷건은 여러 발
                for (let i = 0; i < 5; i++) {
                    bullets.push({
                        x: shooter.x,
                        y: shooter.y,
                        vx: Math.cos(angle + (Math.random() - 0.5) * 0.3) * 10,
                        vy: Math.sin(angle + (Math.random() - 0.5) * 0.3) * 10,
                        damage: weapon.damage / 5,
                        range: weapon.range,
                        owner: shooter,
                        traveled: 0
                    });
                }
            } else {
                bullets.push({
                    x: shooter.x,
                    y: shooter.y,
                    vx: Math.cos(angle) * 12,
                    vy: Math.sin(angle) * 12,
                    damage: weapon.damage,
                    range: weapon.range,
                    owner: shooter,
                    traveled: 0
                });
            }
        }
        
        // 수류탄 투척
        function throwGrenade(thrower, targetX, targetY) {
            if (!thrower.grenades || thrower.grenades <= 0) return;
            
            thrower.grenades--;
            
            const angle = Math.atan2(targetY - thrower.y, targetX - thrower.x);
            const dist = Math.min(200, Math.sqrt((targetX - thrower.x) ** 2 + (targetY - thrower.y) ** 2));
            
            grenades.push({
                x: thrower.x,
                y: thrower.y,
                vx: Math.cos(angle) * dist / 30,
                vy: Math.sin(angle) * dist / 30,
                timer: 5000, // 5초로 변경
                size: 5
            });
        }
        
        // 데미지 처리
        function takeDamage(target, damage) {
            if (target.armor > 0) {
                const armorAbsorb = Math.min(damage * 0.5, target.armor);
                target.armor -= armorAbsorb;
                damage -= armorAbsorb;
            }
            
            target.health -= damage;
            
            if (target === player) {
                // 피격 효과
                document.getElementById('damageIndicator').classList.add('damage-flash');
                setTimeout(() => {
                    document.getElementById('damageIndicator').classList.remove('damage-flash');
                }, 200);
            }
            
            // 파티클 효과
            createBloodParticles(target.x, target.y);
        }
        
        // 파티클 생성
        function createBloodParticles(x, y) {
            for (let i = 0; i < 5; i++) {
                particles.push({
                    x: x,
                    y: y,
                    vx: (Math.random() - 0.5) * 4,
                    vy: (Math.random() - 0.5) * 4,
                    life: 30,
                    color: '#ff0000',
                    size: 2 + Math.random() * 2
                });
            }
        }
        
        // AI 업데이트
        function updateAI(enemy) {
            const now = Date.now();
            
            // 체력이 낮으면 도망
            if (enemy.health < 30) {
                enemy.ai.state = 'flee';
                enemy.ai.fleeTimer = now + 5000;
            }
            
            // 도망 상태에서 체력이 회복되면 다시 순찰
            if (enemy.ai.state === 'flee' && enemy.health > 50 && now > enemy.ai.fleeTimer) {
                enemy.ai.state = 'patrol';
            }
            
            // 근처 아이템 찾기 (파밍) - 더 적극적으로
            if ((enemy.ai.state === 'patrol' || enemy.ai.state === 'search') && (!enemy.weapon || enemy.armor < 50 || enemy.grenades < 2)) {
                let nearestItem = null;
                let nearestDist = 250; // 탐지 거리 증가
                
                items.forEach(item => {
                    if ((item.type === 'weapon' && !enemy.weapon) || 
                        (item.type === 'armor' && enemy.armor < 50) || 
                        (item.type === 'medkit' && enemy.health < 80) ||
                        (item.type === 'grenade' && enemy.grenades < 2) ||
                        (item.type === 'ammo' && enemy.weapon && weapons[enemy.weapon].ammo < weapons[enemy.weapon].maxAmmo / 2)) {
                        const dist = distance(enemy, item);
                        if (dist < nearestDist) {
                            nearestItem = item;
                            nearestDist = dist;
                        }
                    }
                });
                
                if (nearestItem) {
                    enemy.ai.farmingTarget = nearestItem;
                    enemy.ai.state = 'farming';
                }
            }
            
            // 플레이어 감지 - 더 넓은 범위와 지속적인 추적
            const distToPlayer = distance(enemy, player);
            if (distToPlayer < 200 && player.health > 0 && enemy.ai.state !== 'flee') {
                enemy.ai.state = 'combat';
                enemy.target = player;
                enemy.ai.lastPlayerSeen = now;
            }
            
            // 플레이어를 잃어버린 경우 수색 모드
            if (enemy.ai.state === 'combat' && enemy.target === player && distToPlayer > 300) {
                if (now - enemy.ai.lastPlayerSeen > 3000) {
                    enemy.ai.state = 'search';
                    enemy.ai.searchTimer = now + 10000;
                    enemy.target = null;
                }
            }
            
            // 다른 적 감지 - 더 공격적으로
            if (enemy.ai.state !== 'flee' && enemy.weapon) {
                enemies.forEach(other => {
                    if (other !== enemy && distance(enemy, other) < 150) {
                        if (Math.random() < 0.01 * enemy.ai.aggressionLevel) {
                            enemy.ai.state = 'combat';
                            enemy.target = other;
                        }
                    }
                });
            }
            
            switch (enemy.ai.state) {
                case 'patrol':
                    const distToPatrol = distance(enemy, enemy.ai.patrolTarget);
                    if (distToPatrol < 30 || now - enemy.ai.lastStateChange > 5000) {
                        enemy.ai.patrolTarget = {
                            x: Math.random() * MAP_SIZE,
                            y: Math.random() * MAP_SIZE
                        };
                        enemy.ai.lastStateChange = now;
                    }
                    
                    const patrolAngle = angleTo(enemy, enemy.ai.patrolTarget);
                    const patrolSpeed = enemy.speed * (0.6 + Math.random() * 0.4); // 랜덤 속도
                    const newX = enemy.x + Math.cos(patrolAngle) * patrolSpeed;
                    const newY = enemy.y + Math.sin(patrolAngle) * patrolSpeed;
                    
                    if (canMoveTo(newX, newY, enemy.size)) {
                        enemy.x = newX;
                        enemy.y = newY;
                    }
                    break;
                    
                case 'search':
                    // 플레이어를 잃어버린 위치 주변을 수색
                    if (now > enemy.ai.searchTimer) {
                        enemy.ai.state = 'patrol';
                        break;
                    }
                    
                    if (now - enemy.ai.moveTimer > 1000) {
                        enemy.ai.patrolTarget = {
                            x: player.x + (Math.random() - 0.5) * 200,
                            y: player.y + (Math.random() - 0.5) * 200
                        };
                        enemy.ai.moveTimer = now;
                    }
                    
                    const searchAngle = angleTo(enemy, enemy.ai.patrolTarget);
                    const searchSpeed = enemy.speed * 1.2; // 빠른 수색
                    const searchX = enemy.x + Math.cos(searchAngle) * searchSpeed;
                    const searchY = enemy.y + Math.sin(searchAngle) * searchSpeed;
                    
                    if (canMoveTo(searchX, searchY, enemy.size)) {
                        enemy.x = searchX;
                        enemy.y = searchY;
                    }
                    break;
                    
                case 'farming':
                    if (!enemy.ai.farmingTarget) {
                        enemy.ai.state = 'patrol';
                        break;
                    }
                    
                    const distToItem = distance(enemy, enemy.ai.farmingTarget);
                    if (distToItem < 20) {
                        // 아이템 획득
                        const item = enemy.ai.farmingTarget;
                        if (item.type === 'weapon') {
                            enemy.weapon = item.data.weaponType;
                        } else if (item.type === 'armor') {
                            enemy.armor = Math.min(100, enemy.armor + item.data.amount);
                        } else if (item.type === 'medkit') {
                            enemy.health = Math.min(100, enemy.health + item.data.amount);
                        } else if (item.type === 'grenade') {
                            enemy.grenades = Math.min(5, enemy.grenades + item.data.amount);
                        } else if (item.type === 'ammo' && enemy.weapon) {
                            const weapon = weapons[enemy.weapon];
                            if (weapon.ammoType === item.data.ammoType) {
                                weapon.ammo = Math.min(weapon.maxAmmo, weapon.ammo + item.data.amount);
                            }
                        }
                        
                        // 아이템 제거
                        const itemIndex = items.indexOf(item);
                        if (itemIndex > -1) {
                            items.splice(itemIndex, 1);
                        }
                        
                        enemy.ai.farmingTarget = null;
                        enemy.ai.state = 'patrol';
                    } else {
                        const farmAngle = angleTo(enemy, enemy.ai.farmingTarget);
                        const farmSpeed = enemy.speed * 1.5; // 빠른 파밍
                        const farmX = enemy.x + Math.cos(farmAngle) * farmSpeed;
                        const farmY = enemy.y + Math.sin(farmAngle) * farmSpeed;
                        
                        if (canMoveTo(farmX, farmY, enemy.size)) {
                            enemy.x = farmX;
                            enemy.y = farmY;
                        }
                    }
                    break;
                    
                case 'combat':
                    if (!enemy.target || enemy.target.health <= 0) {
                        enemy.ai.state = 'patrol';
                        enemy.target = null;
                        break;
                    }
                    
                    const distToTarget = distance(enemy, enemy.target);
                    if (distToTarget > 350) {
                        if (enemy.target === player) {
                            enemy.ai.state = 'search';
                            enemy.ai.searchTimer = now + 8000;
                        } else {
                            enemy.ai.state = 'patrol';
                        }
                        enemy.target = null;
                        break;
                    }
                    
                    // 전투 중 움직임 - 더 역동적으로
                    const combatAngle = angleTo(enemy, enemy.target);
                    let moveAngle = combatAngle;
                    
                    // 가끔 옆으로 이동하거나 후퇴
                    if (Math.random() < 0.3) {
                        moveAngle += (Math.random() - 0.5) * Math.PI; // 옆으로 이동
                    } else if (distToTarget < 80 && Math.random() < 0.2) {
                        moveAngle += Math.PI; // 후퇴
                    }
                    
                    const combatSpeed = enemy.speed * (distToTarget > 120 ? 1.3 : 0.8);
                    const combatX = enemy.x + Math.cos(moveAngle) * combatSpeed;
                    const combatY = enemy.y + Math.sin(moveAngle) * combatSpeed;
                    
                    if (canMoveTo(combatX, combatY, enemy.size)) {
                        enemy.x = combatX;
                        enemy.y = combatY;
                    }
                    
                    // 사격 - 더 적극적으로
                    if (distToTarget < 250) {
                        // 무기가 있으면 무기 사용
                        if (enemy.weapon && Math.random() < 0.04 * enemy.ai.aggressionLevel) {
                            shoot(enemy, enemy.target.x, enemy.target.y);
                        }
                        // 무기가 없으면 주먹 사용
                        else if (!enemy.weapon && distToTarget < 80 && Math.random() < 0.06 * enemy.ai.aggressionLevel) {
                            // 주먹 공격 (근접)
                            if (distToTarget < 30) {
                                takeDamage(enemy.target, 15);
                                enemy.lastShot = Date.now();
                            }
                        }
                        
                        // 수류탄 사용
                        if (enemy.grenades > 0 && distToTarget > 80 && distToTarget < 200 && 
                            Date.now() - enemy.ai.lastGrenadeThrow > 8000 && Math.random() < 0.02) {
                            throwGrenade(enemy, enemy.target.x, enemy.target.y);
                            enemy.ai.lastGrenadeThrow = Date.now();
                        }
                    }
                    break;
                    
                case 'flee':
                    // 플레이어나 적들로부터 도망 - 더 빠르게
                    let fleeX = 0, fleeY = 0;
                    let threatCount = 0;
                    
                    if (distance(enemy, player) < 250) {
                        const angle = angleTo(player, enemy);
                        fleeX += Math.cos(angle);
                        fleeY += Math.sin(angle);
                        threatCount++;
                    }
                    
                    enemies.forEach(other => {
                        if (other !== enemy && distance(enemy, other) < 180) {
                            const angle = angleTo(other, enemy);
                            fleeX += Math.cos(angle);
                            fleeY += Math.sin(angle);
                            threatCount++;
                        }
                    });
                    
                    if (threatCount > 0) {
                        fleeX /= threatCount;
                        fleeY /= threatCount;
                        
                        const fleeSpeed = enemy.speed * 2; // 빠른 도망
                        const newFleeX = enemy.x + fleeX * fleeSpeed;
                        const newFleeY = enemy.y + fleeY * fleeSpeed;
                        
                        if (canMoveTo(newFleeX, newFleeY, enemy.size)) {
                            enemy.x = newFleeX;
                            enemy.y = newFleeY;
                        }
                    }
                    break;
            }
        }
        
        // 업데이트
        function update() {
            if (gameState !== 'playing') return;
            
            // 연사 처리
            if (mousePressed || keys[' ']) {
                const currentWeapon = player.weapons[player.currentWeapon];
                if (currentWeapon && (currentWeapon.autoFire || player.currentWeapon === 'grenade')) {
                    const worldMouseX = mouseX + camera.x;
                    const worldMouseY = mouseY + camera.y;
                    shoot(player, worldMouseX, worldMouseY);
                }
            }
            
            // 플레이어 이동
            let moveX = 0, moveY = 0;
            if (keys['w']) moveY -= 1;
            if (keys['s']) moveY += 1;
            if (keys['a']) moveX -= 1;
            if (keys['d']) moveX += 1;
            
            // 달리기 체크
            player.isRunning = keys['shift'];
            
            if (moveX !== 0 || moveY !== 0) {
                const length = Math.sqrt(moveX * moveX + moveY * moveY);
                moveX /= length;
                moveY /= length;
                
                let speed = player.speed;
                if (player.isRunning) {
                    speed *= 1.8; // 달리기 시 1.8배 빠름
                } else if (isAiming) {
                    speed *= 0.5; // 조준 시 0.5배 느림
                }
                
                const newX = player.x + moveX * speed;
                const newY = player.y + moveY * speed;
                
                if (canMoveTo(newX, player.y, player.size)) {
                    player.x = newX;
                }
                if (canMoveTo(player.x, newY, player.size)) {
                    player.y = newY;
                }
            }
            
            // 카메라 업데이트
            if (isAiming) {
                // 정밀조준 시 마우스 방향으로 카메라 이동
                const worldMouseX = mouseX + camera.x;
                const worldMouseY = mouseY + camera.y;
                const aimOffsetX = (worldMouseX - player.x) * 0.3;
                const aimOffsetY = (worldMouseY - player.y) * 0.3;
                
                camera.x = player.x - canvas.width / (2 * zoom) + aimOffsetX;
                camera.y = player.y - canvas.height / (2 * zoom) + aimOffsetY;
            } else {
                camera.x = player.x - canvas.width / (2 * zoom);
                camera.y = player.y - canvas.height / (2 * zoom);
            }
            
            // 줌 업데이트 (SR은 더 큰 줌)
            if (isAiming && player.currentWeapon === 'sr') {
                zoom = 2.0; // SR 조준 시 2배 줌
            } else if (isAiming) {
                zoom = 1.3; // 일반 조준 시 1.3배 줌
            } else {
                zoom = 1;
            }
            
            // 총알 업데이트
            bullets.forEach((bullet, index) => {
                bullet.x += bullet.vx;
                bullet.y += bullet.vy;
                bullet.traveled += Math.sqrt(bullet.vx * bullet.vx + bullet.vy * bullet.vy);
                
                if (bullet.traveled > bullet.range) {
                    bullets.splice(index, 1);
                    return;
                }
                
                // 장애물 충돌
                for (let obstacle of obstacles) {
                    if (bullet.x > obstacle.x && bullet.x < obstacle.x + obstacle.width &&
                        bullet.y > obstacle.y && bullet.y < obstacle.y + obstacle.height) {
                        bullets.splice(index, 1);
                        return;
                    }
                }
                
                // 플레이어 충돌
                if (bullet.owner !== player && distance(bullet, player) < player.size) {
                    takeDamage(player, bullet.damage);
                    bullets.splice(index, 1);
                    return;
                }
                
                    enemies.forEach((enemy, enemyIndex) => {
                        if (bullet.owner !== enemy && distance(bullet, enemy) < enemy.size) {
                            takeDamage(enemy, bullet.damage);
                            bullets.splice(index, 1);
                            
                            if (enemy.health <= 0) {
                                if (bullet.owner === player) {
                                    player.kills++;
                                }
                                enemies.splice(enemyIndex, 1);
                            }
                        }
                    });
            });
            
            // 수류탄 업데이트
            grenades.forEach((grenade, index) => {
                grenade.x += grenade.vx;
                grenade.y += grenade.vy;
                grenade.vx *= 0.98;
                grenade.vy *= 0.98;
                grenade.timer -= 16;
                
                // 폭발 직전 효과 (1000ms 전부터)
                if (grenade.timer <= 1000 && grenade.timer > 0) {
                    if (Math.random() < 0.3) {
                        particles.push({
                            x: grenade.x + (Math.random() - 0.5) * 10,
                            y: grenade.y + (Math.random() - 0.5) * 10,
                            vx: (Math.random() - 0.5) * 2,
                            vy: (Math.random() - 0.5) * 2,
                            life: 20,
                            color: '#ff4400',
                            size: 2
                        });
                    }
                }
                
                if (grenade.timer <= 0) {
                    // 폭발
                    const explosionRadius = 80;
                    
                    // 플레이어 데미지
                    const distToPlayer = distance(grenade, player);
                    if (distToPlayer < explosionRadius) {
                        const damage = 60 * (1 - distToPlayer / explosionRadius);
                        takeDamage(player, damage);
                    }
                    
                    // 적 데미지
                    enemies.forEach((enemy, enemyIndex) => {
                        const distToEnemy = distance(grenade, enemy);
                        if (distToEnemy < explosionRadius) {
                            const damage = 60 * (1 - distToEnemy / explosionRadius);
                            takeDamage(enemy, damage);
                            
                            if (enemy.health <= 0) {
                                player.kills++;
                                enemies.splice(enemyIndex, 1);
                            }
                        }
                    });
                    
                    // 폭발 파티클 효과
                    for (let i = 0; i < 30; i++) {
                        particles.push({
                            x: grenade.x,
                            y: grenade.y,
                            vx: (Math.random() - 0.5) * 15,
                            vy: (Math.random() - 0.5) * 15,
                            life: 60,
                            color: i < 15 ? '#ff8800' : '#ffaa00',
                            size: 4 + Math.random() * 4
                        });
                    }
                    
                    // 연기 파티클
                    for (let i = 0; i < 20; i++) {
                        particles.push({
                            x: grenade.x,
                            y: grenade.y,
                            vx: (Math.random() - 0.5) * 8,
                            vy: (Math.random() - 0.5) * 8,
                            life: 100,
                            color: '#666666',
                            size: 6 + Math.random() * 6
                        });
                    }
                    
                    grenades.splice(index, 1);
                }
            });
            
            // AI 업데이트
            enemies.forEach(enemy => {
                updateAI(enemy);
            });
            
            // 파티클 업데이트
            particles.forEach((particle, index) => {
                particle.x += particle.vx;
                particle.y += particle.vy;
                particle.vx *= 0.95;
                particle.vy *= 0.95;
                particle.life--;
                
                if (particle.life <= 0) {
                    particles.splice(index, 1);
                }
            });
            
            // 게임 종료 체크
            if (player.health <= 0) {
                gameState = 'gameOver';
                document.getElementById('gameResult').textContent = '사망!';
                document.getElementById('finalRank').textContent = `순위: ${enemies.length + 1}위`;
                document.getElementById('gameOver').style.display = 'block';
            } else if (enemies.length === 0) {
                gameState = 'gameOver';
                document.getElementById('gameResult').textContent = '승리!';
                document.getElementById('finalRank').textContent = '순위: 1위';
                document.getElementById('gameOver').style.display = 'block';
            }
            
            updateHUD();
        }
        
        // 렌더링
        function render() {
            // 메인 캔버스 클리어
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            ctx.save();
            ctx.scale(zoom, zoom);
            ctx.translate(-camera.x, -camera.y);
            
            // 배경 (잔디) - Canvas로 텍스처 생성
            drawGrassTexture();
            
            // 집 그리기 (장식용, 통과 가능)
            houses.forEach(house => {
                // 집 바닥
                ctx.fillStyle = '#D2B48C';
                ctx.fillRect(house.x, house.y, house.width, house.height);
                
                // 집 벽 (시각적으로만, 충돌 없음)
                ctx.strokeStyle = '#8B4513';
                ctx.lineWidth = 8;
                ctx.strokeRect(house.x, house.y, house.width, house.height);
                
                // 문
                ctx.fillStyle = '#654321';
                ctx.fillRect(house.doorX, house.doorY - 5, house.doorWidth, house.doorHeight);
                
                // 지붕
                ctx.fillStyle = '#A0522D';
                ctx.beginPath();
                ctx.moveTo(house.x - 10, house.y);
                ctx.lineTo(house.x + house.width / 2, house.y - 20);
                ctx.lineTo(house.x + house.width + 10, house.y);
                ctx.closePath();
                ctx.fill();
                
                // 창문
                ctx.fillStyle = '#87CEEB';
                ctx.fillRect(house.x + 15, house.y + 15, 12, 12);
                ctx.fillRect(house.x + house.width - 27, house.y + 15, 12, 12);
            });
            
            // 장애물
            obstacles.forEach(obstacle => {
                drawObstacle(obstacle);
            });
            
            // 아이템
            items.forEach(item => {
                drawItem(item);
            });
            
            // 적들
            enemies.forEach(enemy => {
                drawEnemy(enemy);
            });
            
            // 플레이어
            drawPlayer();
            
            // 총알 (더 크고 눈에 잘 띄게)
            bullets.forEach(bullet => {
                ctx.fillStyle = '#ffff00';
                ctx.shadowColor = '#ffff00';
                ctx.shadowBlur = 8;
                ctx.beginPath();
                ctx.arc(bullet.x, bullet.y, 4, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;
                
                // 총알 궤적
                ctx.strokeStyle = '#ffff88';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(bullet.x - bullet.vx * 2, bullet.y - bullet.vy * 2);
                ctx.lineTo(bullet.x, bullet.y);
                ctx.stroke();
            });
            
            // 수류탄
            ctx.fillStyle = '#8B0000';
            grenades.forEach(grenade => {
                ctx.beginPath();
                ctx.arc(grenade.x, grenade.y, grenade.size, 0, Math.PI * 2);
                ctx.fill();
            });
            
            // 파티클
            particles.forEach(particle => {
                ctx.fillStyle = particle.color;
                ctx.globalAlpha = particle.life / 40;
                ctx.beginPath();
                ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1;
            });
            
            ctx.restore();
            
            // 미니맵
            renderMinimap();
        }
        
        // 잔디 텍스처 그리기
        function drawGrassTexture() {
            // 기본 잔디 색상
            ctx.fillStyle = '#90EE90';
            ctx.fillRect(0, 0, MAP_SIZE, MAP_SIZE);
            
            // 카메라 영역만 텍스처 그리기 (성능 최적화)
            const startX = Math.max(0, Math.floor(camera.x / 100) * 100);
            const endX = Math.min(MAP_SIZE, Math.ceil((camera.x + canvas.width / zoom) / 100) * 100);
            const startY = Math.max(0, Math.floor(camera.y / 100) * 100);
            const endY = Math.min(MAP_SIZE, Math.ceil((camera.y + canvas.height / zoom) / 100) * 100);
            
            // 잔디 패턴
            ctx.fillStyle = '#7CFC00';
            for (let x = startX; x < endX; x += 20) {
                for (let y = startY; y < endY; y += 20) {
                    // 시드 기반 랜덤으로 일관된 패턴
                    const seed = (x * 73 + y * 37) % 1000;
                    if (seed < 300) {
                        ctx.fillRect(x + (seed % 15), y + ((seed * 7) % 15), 2, 2);
                    }
                }
            }
            
            // 더 진한 잔디 패치
            ctx.fillStyle = '#228B22';
            for (let x = startX; x < endX; x += 40) {
                for (let y = startY; y < endY; y += 40) {
                    const seed = (x * 31 + y * 17) % 1000;
                    if (seed < 150) {
                        ctx.fillRect(x + (seed % 20), y + ((seed * 3) % 20), 3, 3);
                    }
                }
            }
        }
        
        // 장애물 그리기
        function drawObstacle(obstacle) {
            if (obstacle.type === 'tree') {
                // 나무 그리기
                ctx.fillStyle = '#228B22'; // 나뭇잎
                ctx.fillRect(obstacle.x, obstacle.y, obstacle.width, obstacle.height * 0.7);
                
                ctx.fillStyle = '#8B4513'; // 나무 줄기
                const trunkWidth = obstacle.width * 0.3;
                const trunkHeight = obstacle.height * 0.4;
                ctx.fillRect(
                    obstacle.x + (obstacle.width - trunkWidth) / 2, 
                    obstacle.y + obstacle.height * 0.6, 
                    trunkWidth, 
                    trunkHeight
                );
                
                // 나뭇잎 텍스처
                ctx.fillStyle = '#32CD32';
                for (let i = 0; i < 10; i++) {
                    const leafX = obstacle.x + Math.random() * obstacle.width;
                    const leafY = obstacle.y + Math.random() * obstacle.height * 0.7;
                    ctx.fillRect(leafX, leafY, 2, 2);
                }
            } else if (obstacle.type === 'rock') {
                // 바위 그리기
                ctx.fillStyle = '#696969';
                ctx.fillRect(obstacle.x, obstacle.y, obstacle.width, obstacle.height);
                
                // 바위 텍스처
                ctx.fillStyle = '#808080';
                for (let i = 0; i < 8; i++) {
                    const rockX = obstacle.x + Math.random() * obstacle.width;
                    const rockY = obstacle.y + Math.random() * obstacle.height;
                    ctx.fillRect(rockX, rockY, 3, 3);
                }
                
                ctx.fillStyle = '#A9A9A9';
                for (let i = 0; i < 5; i++) {
                    const lightX = obstacle.x + Math.random() * obstacle.width;
                    const lightY = obstacle.y + Math.random() * obstacle.height;
                    ctx.fillRect(lightX, lightY, 2, 2);
                }
            }
        }
        
        // 아이템 그리기
        function drawItem(item) {
            // 아이템별 고유한 모양 그리기
            switch(item.type) {
                case 'weapon':
                    drawWeaponItem(item);
                    break;
                case 'ammo':
                    drawAmmoItem(item);
                    break;
                case 'armor':
                    drawArmorItem(item);
                    break;
                case 'medkit':
                    drawMedkitItem(item);
                    break;
                case 'bandage':
                    drawBandageItem(item);
                    break;
                case 'grenade':
                    drawGrenadeItem(item);
                    break;
            }
        }
        
        function drawWeaponItem(item) {
            const weaponType = item.data.weaponType;
            ctx.save();
            ctx.translate(item.x, item.y);
            
            switch(weaponType) {
                case 'ar':
                    ctx.fillStyle = '#2F4F4F';
                    ctx.fillRect(-12, -2, 24, 4);
                    ctx.fillRect(8, -3, 6, 6);
                    break;
                case 'shotgun':
                    ctx.fillStyle = '#8B4513';
                    ctx.fillRect(-15, -3, 30, 6);
                    ctx.fillRect(10, -4, 8, 8);
                    break;
                case 'smg':
                    ctx.fillStyle = '#696969';
                    ctx.fillRect(-10, -2, 20, 4);
                    ctx.fillRect(6, -3, 6, 6);
                    break;
                case 'sr':
                    ctx.fillStyle = '#556B2F';
                    ctx.fillRect(-18, -1, 36, 2);
                    ctx.fillRect(12, -4, 8, 8);
                    break;
            }
            
            ctx.restore();
        }
        
        function drawAmmoItem(item) {
            ctx.fillStyle = '#FFA500';
            ctx.fillRect(item.x - 6, item.y - 8, 12, 16);
            ctx.fillStyle = '#FFD700';
            ctx.fillRect(item.x - 4, item.y - 6, 8, 4);
            ctx.fillRect(item.x - 4, item.y + 2, 8, 4);
        }
        
        function drawArmorItem(item) {
            ctx.fillStyle = '#4169E1';
            ctx.beginPath();
            ctx.arc(item.x, item.y - 3, 8, 0, Math.PI, true);
            ctx.fill();
            ctx.fillRect(item.x - 8, item.y - 3, 16, 10);
            ctx.fillStyle = '#6495ED';
            ctx.fillRect(item.x - 6, item.y - 1, 12, 6);
        }
        
        function drawMedkitItem(item) {
            ctx.fillStyle = '#32CD32';
            ctx.fillRect(item.x - 8, item.y - 6, 16, 12);
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(item.x - 1, item.y - 4, 2, 8);
            ctx.fillRect(item.x - 4, item.y - 1, 8, 2);
        }
        
        function drawBandageItem(item) {
            ctx.fillStyle = '#F5F5DC';
            ctx.fillRect(item.x - 6, item.y - 3, 12, 6);
            ctx.fillStyle = '#FF6347';
            ctx.fillRect(item.x - 1, item.y - 2, 2, 4);
        }
        
        function drawGrenadeItem(item) {
            ctx.fillStyle = '#8B0000';
            ctx.beginPath();
            ctx.arc(item.x, item.y, 6, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#A0522D';
            ctx.fillRect(item.x - 2, item.y - 8, 4, 4);
        }
        
        // 적 그리기
        function drawEnemy(enemy) {
            ctx.fillStyle = '#ff4444';
            ctx.beginPath();
            ctx.arc(enemy.x, enemy.y, enemy.size, 0, Math.PI * 2);
            ctx.fill();
            
            // 체력바
            if (enemy.health < 100) {
                ctx.fillStyle = '#000';
                ctx.fillRect(enemy.x - 15, enemy.y - 25, 30, 4);
                ctx.fillStyle = '#ff0000';
                ctx.fillRect(enemy.x - 15, enemy.y - 25, 30 * (enemy.health / 100), 4);
            }
            
            // 무기 표시
            if (enemy.weapon) {
                ctx.fillStyle = '#000';
                ctx.font = '8px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(enemy.weapon.toUpperCase(), enemy.x, enemy.y + 25);
            }
        }
        
        // 플레이어 그리기
        function drawPlayer() {
            // 기본 플레이어
            ctx.fillStyle = '#4444ff';
            ctx.beginPath();
            ctx.arc(player.x, player.y, player.size, 0, Math.PI * 2);
            ctx.fill();
            
            // 방어구 착용 시 외곽선 추가
            if (player.armor > 0) {
                ctx.strokeStyle = '#4169E1';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(player.x, player.y, player.size + 2, 0, Math.PI * 2);
                ctx.stroke();
                
                // 방어구 플레이트 표시
                ctx.fillStyle = '#6495ED';
                ctx.fillRect(player.x - 8, player.y - 12, 16, 8);
                ctx.fillRect(player.x - 6, player.y + 8, 12, 6);
            }
            
            // 무기 표시
            ctx.fillStyle = '#000';
            ctx.font = '10px Arial';
            ctx.textAlign = 'center';
            const weaponName = player.weapons[player.currentWeapon].name;
            ctx.fillText(weaponName, player.x, player.y + 25);
            
            // 무기 그리기 (마우스 방향)
            const worldMouseX = mouseX + camera.x;
            const worldMouseY = mouseY + camera.y;
            const angle = Math.atan2(worldMouseY - player.y, worldMouseX - player.x);
            
            drawWeapon(player.x, player.y, angle, player.currentWeapon);
        }
        
        // 무기 그리기 함수
        function drawWeapon(x, y, angle, weaponType) {
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(angle);
            
            switch(weaponType) {
                case 'fist':
                    ctx.fillStyle = '#FFB6C1';
                    ctx.fillRect(15, -3, 8, 6);
                    break;
                case 'ar':
                    ctx.fillStyle = '#2F4F4F';
                    ctx.fillRect(15, -2, 25, 4);
                    ctx.fillRect(35, -4, 8, 8);
                    ctx.fillRect(20, -1, 3, 2);
                    break;
                case 'shotgun':
                    ctx.fillStyle = '#8B4513';
                    ctx.fillRect(15, -3, 30, 6);
                    ctx.fillRect(40, -5, 10, 10);
                    ctx.fillRect(25, -2, 2, 4);
                    break;
                case 'smg':
                    ctx.fillStyle = '#696969';
                    ctx.fillRect(15, -2, 20, 4);
                    ctx.fillRect(30, -3, 6, 6);
                    ctx.fillRect(18, -1, 2, 2);
                    break;
                case 'sr':
                    ctx.fillStyle = '#556B2F';
                    ctx.fillRect(15, -1, 35, 2);
                    ctx.fillRect(45, -4, 8, 8);
                    ctx.fillRect(25, -3, 15, 6);
                    break;
            }
            
            ctx.restore();
        }
        
        // 미니맵 렌더링
        function renderMinimap() {
            minimapCtx.clearRect(0, 0, 150, 150);
            
            const scale = 150 / MAP_SIZE;
            
            // 배경
            minimapCtx.fillStyle = '#90EE90';
            minimapCtx.fillRect(0, 0, 150, 150);
            
            // 플레이어
            minimapCtx.fillStyle = '#4444ff';
            minimapCtx.beginPath();
            minimapCtx.arc(player.x * scale, player.y * scale, 3, 0, Math.PI * 2);
            minimapCtx.fill();
            
            // 적들
            minimapCtx.fillStyle = '#ff4444';
            enemies.forEach(enemy => {
                minimapCtx.beginPath();
                minimapCtx.arc(enemy.x * scale, enemy.y * scale, 2, 0, Math.PI * 2);
                minimapCtx.fill();
            });
        }
        
        // HUD 업데이트
        function updateHUD() {
            document.getElementById('healthText').textContent = Math.max(0, Math.floor(player.health));
            document.getElementById('armorText').textContent = Math.max(0, Math.floor(player.armor));
            document.getElementById('healthFill').style.width = Math.max(0, player.health) + '%';
            document.getElementById('armorFill').style.width = Math.max(0, player.armor) + '%';
            document.getElementById('aliveCount').textContent = enemies.length + (player.health > 0 ? 1 : 0);
            
            // 무기 정보 업데이트
            const weaponInfo = document.getElementById('weaponInfo');
            
            let weaponDisplay = '';
            
            if (player.currentWeapon === 'grenade') {
                weaponDisplay = `<div id="weaponName">수류탄</div>`;
                weaponDisplay += `<div id="ammoCount">${player.grenades}</div>`;
            } else {
                const currentWeapon = player.weapons[player.currentWeapon];
                weaponDisplay = `<div id="weaponName">${currentWeapon.name}</div>`;
                
                if (currentWeapon.ammo === -1) {
                    weaponDisplay += `<div id="ammoCount">∞</div>`;
                } else {
                    weaponDisplay += `<div id="ammoCount">${currentWeapon.ammo}/${currentWeapon.maxAmmo}</div>`;
                }
            }
            
            // 킬 수 표시
            weaponDisplay += `<div>킬: ${player.kills}</div>`;
            
            if (player.grenades > 0) {
                weaponDisplay += `<div>수류탄: ${player.grenades}</div>`;
            }
            
            // 보유 무기 목록 (최대 4개 슬롯)
            const weaponKeys = Object.keys(player.weapons);
            weaponDisplay += `<div style="font-size: 12px; margin-top: 5px;">`;
            
            // 슬롯 1: 주먹 (항상 있음)
            const fistActive = player.currentWeapon === 'fist';
            weaponDisplay += `<div style="color: ${fistActive ? '#ffff00' : '#ffffff'}">1: 주먹</div>`;
            
            // 슬롯 2, 3: 무기들
            const otherWeapons = weaponKeys.filter(key => key !== 'fist');
            for (let i = 0; i < 2; i++) {
                const slotNum = i + 2;
                if (i < otherWeapons.length) {
                    const weaponKey = otherWeapons[i];
                    const weapon = player.weapons[weaponKey];
                    const isActive = weaponKey === player.currentWeapon;
                    weaponDisplay += `<div style="color: ${isActive ? '#ffff00' : '#ffffff'}">
                        ${slotNum}: ${weapon.name}
                    </div>`;
                } else {
                    weaponDisplay += `<div style="color: #666666">${slotNum}: 빈 슬롯</div>`;
                }
            }
            
            // 슬롯 4: 수류탄
            const grenadeActive = player.currentWeapon === 'grenade';
            if (player.grenades > 0) {
                weaponDisplay += `<div style="color: ${grenadeActive ? '#ffff00' : '#ffffff'}">4: 수류탄 (${player.grenades})</div>`;
            } else {
                weaponDisplay += `<div style="color: #666666">4: 수류탄 (0)</div>`;
            }
            
            weaponDisplay += `</div>`;
            weaponInfo.innerHTML = weaponDisplay;
        }
        
        // 게임 루프
        function gameLoop() {
            update();
            render();
            requestAnimationFrame(gameLoop);
        }
        
        // 이벤트 리스너
        document.addEventListener('keydown', (e) => {
            keys[e.key.toLowerCase()] = true;
            
            if (e.key === 'e' || e.key === 'E') {
                isAiming = true;
            }
            
            if (e.key === 'r' || e.key === 'R') {
                if (player.currentWeapon !== 'fist') {
                    const weapon = player.weapons[player.currentWeapon];
                    weapon.ammo = weapon.maxAmmo;
                }
            }
            
            if (e.key === 'f' || e.key === 'F') {
                // 아이템 획득
                items.forEach((item, index) => {
                    if (distance(player, item) < 30) {
                        if (item.type === 'weapon') {
                            const weaponType = item.data.weaponType;
                            const weaponKeys = Object.keys(player.weapons).filter(key => key !== 'fist');
                            
                            if (weaponKeys.length < 2) {
                                // 무기 슬롯이 있으면 추가
                                const weaponData = { ...weapons[weaponType] };
                                player.weapons[weaponType] = weaponData;
                                player.currentWeapon = weaponType;
                            } else {
                                // 무기 슬롯이 가득 찬 경우 현재 무기와 교체
                                if (player.currentWeapon !== 'fist') {
                                    delete player.weapons[player.currentWeapon];
                                }
                                const weaponData = { ...weapons[weaponType] };
                                player.weapons[weaponType] = weaponData;
                                player.currentWeapon = weaponType;
                            }
                        } else if (item.type === 'armor') {
                            player.armor = Math.min(100, player.armor + item.data.amount);
                        } else if (item.type === 'medkit') {
                            if (player.health < 100) {
                                player.health = Math.min(100, player.health + item.data.amount);
                            }
                        } else if (item.type === 'bandage') {
                            if (player.health < 75) {
                                player.health = Math.min(75, player.health + item.data.amount);
                            }
                        } else if (item.type === 'grenade') {
                            player.grenades = (player.grenades || 0) + item.data.amount;
                        } else if (item.type === 'ammo') {
                            // 보유한 무기 중 해당 탄약 타입과 맞는 무기에 탄약 추가
                            Object.keys(player.weapons).forEach(weaponKey => {
                                const weapon = player.weapons[weaponKey];
                                const originalWeapon = weapons[weaponKey];
                                if (originalWeapon && originalWeapon.ammoType === item.data.ammoType) {
                                    weapon.ammo = Math.min(weapon.maxAmmo, weapon.ammo + item.data.amount);
                                }
                            });
                        }
                        items.splice(index, 1);
                    }
                });
            }
            
            // 무기 선택
            if (e.key === '1') {
                player.currentWeapon = 'fist';
            }
            
            if (e.key === '2') {
                const weaponKeys = Object.keys(player.weapons).filter(key => key !== 'fist');
                if (weaponKeys.length > 0) {
                    player.currentWeapon = weaponKeys[0];
                }
            }
            
            if (e.key === '3') {
                const weaponKeys = Object.keys(player.weapons).filter(key => key !== 'fist');
                if (weaponKeys.length > 1) {
                    player.currentWeapon = weaponKeys[1];
                }
            }
            
            // 수류탄 선택
            if (e.key === '4') {
                if (player.grenades > 0) {
                    player.currentWeapon = 'grenade';
                }
            }
            
            // 무기 버리기
            if (e.key === 'q' || e.key === 'Q') {
                if (player.currentWeapon !== 'fist') {
                    // 현재 무기를 땅에 떨어뜨리기
                    items.push({
                        x: player.x + (Math.random() - 0.5) * 30,
                        y: player.y + (Math.random() - 0.5) * 30,
                        type: 'weapon',
                        data: { weaponType: player.currentWeapon },
                        ...itemTypes.weapon
                    });
                    
                    delete player.weapons[player.currentWeapon];
                    player.currentWeapon = 'fist';
                }
            }
            
            if (e.key === 'g' || e.key === 'G') {
                // G키는 더 이상 수류탄 투척에 사용하지 않음 (4번 키 + 사격으로 변경)
            }
        });
        
        document.addEventListener('keyup', (e) => {
            keys[e.key.toLowerCase()] = false;
            
            if (e.key === 'e' || e.key === 'E') {
                isAiming = false;
            }
        });
        
        document.addEventListener('mousemove', (e) => {
            mouseX = e.clientX;
            mouseY = e.clientY;
        });
        
        document.addEventListener('mousedown', (e) => {
            if (e.button === 0) { // 좌클릭
                mousePressed = true;
                const worldMouseX = mouseX + camera.x;
                const worldMouseY = mouseY + camera.y;
                
                // 단발 무기는 클릭 시에만 발사
                const currentWeapon = player.weapons[player.currentWeapon];
                if (currentWeapon && !currentWeapon.autoFire) {
                    shoot(player, worldMouseX, worldMouseY);
                }
            }
        });
        
        document.addEventListener('mouseup', (e) => {
            if (e.button === 0) {
                mousePressed = false;
            }
        });
        
        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space') {
                e.preventDefault();
                keys[' '] = true;
                
                // 단발 무기는 키 다운 시에만 발사
                const currentWeapon = player.weapons[player.currentWeapon];
                if (currentWeapon && !currentWeapon.autoFire) {
                    const worldMouseX = mouseX + camera.x;
                    const worldMouseY = mouseY + camera.y;
                    shoot(player, worldMouseX, worldMouseY);
                }
            }
        });
        
        document.addEventListener('keyup', (e) => {
            if (e.code === 'Space') {
                keys[' '] = false;
            }
        });
        
        // 게임 시작
        init();
    </script>
</body>
</html>