<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no">
    <title>FPS ë°°í‹€ë¡œì–„ - ìµœí›„ì˜ 1ì¸</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Orbitron', monospace;
            background: linear-gradient(135deg, #0c0c0c 0%, #1a1a2e 50%, #16213e 100%);
            overflow: hidden;
            cursor: crosshair;
            user-select: none;
            zoom: 1;
            -moz-transform: scale(1);
            -webkit-transform: scale(1);
            transform: scale(1);
            -ms-zoom: 1;
            touch-action: manipulation;
        }
        
        #gameContainer {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        canvas {
            display: block;
            background: #2d5016;
            width: 100vw;
            height: 100vh;
            border: none;
            border-radius: 0;
        }
        
        #hud {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: #00ffff;
            font-weight: bold;
            text-shadow: 0 0 10px #00ffff, 0 0 20px #00ffff;
            background: rgba(0,0,0,0.7);
            padding: 15px;
            border-radius: 10px;
            border: 2px solid #00ffff;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }
        
        #currentWeapon {
            font-size: 16px;
            color: #ffff00;
            text-align: center;
            margin-bottom: 5px;
        }
        
        #healthArmorSection {
            display: flex;
            gap: 30px;
            align-items: center;
        }
        
        #healthSection, #armorSection {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        #healthBar, #armorBar {
            width: 150px;
            height: 20px;
            background: rgba(0,0,0,0.8);
            border: 2px solid #00ffff;
            margin: 5px 0;
            position: relative;
            border-radius: 10px;
            overflow: hidden;
        }
        
        #healthFill {
            height: 100%;
            background: linear-gradient(90deg, #ff4444, #ff6666, #ff8888);
            width: 100%;
            transition: width 0.3s ease;
            border-radius: 8px;
            box-shadow: 0 0 10px rgba(255,68,68,0.5);
        }
        
        #armorFill {
            height: 100%;
            background: linear-gradient(90deg, #4444ff, #6666ff, #8888ff);
            width: 100%;
            transition: width 0.3s ease;
            border-radius: 8px;
            box-shadow: 0 0 10px rgba(68,68,255,0.5);
        }
        
        #inventoryInfo {
            position: absolute;
            bottom: 20px;
            left: 220px;
            color: #00ffff;
            font-size: 14px;
            font-weight: bold;
            text-shadow: 0 0 10px #00ffff;
            background: rgba(0,0,0,0.7);
            padding: 15px;
            border-radius: 10px;
            border: 2px solid #00ffff;
            min-width: 150px;
        }
        
        #damageIndicator {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
            border: 15px solid transparent;
            transition: border-color 0.3s ease;
            border-radius: 10px;
        }
        
        .damage-flash {
            border-color: rgba(255, 0, 0, 0.7) !important;
            animation: damageFlash 0.5s ease-out;
        }
        
        .zone-warning {
            border-color: rgba(0, 100, 255, 0.5) !important;
            animation: zoneWarning 1s ease-in-out infinite;
        }
        
        @keyframes damageFlash {
            0% { border-color: rgba(255, 0, 0, 0.8); }
            50% { border-color: rgba(255, 0, 0, 0.4); }
            100% { border-color: transparent; }
        }
        
        @keyframes zoneWarning {
            0% { border-color: rgba(0, 100, 255, 0.3); }
            50% { border-color: rgba(0, 100, 255, 0.7); }
            100% { border-color: rgba(0, 100, 255, 0.3); }
        }
        
        #gameOver {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, rgba(0,0,0,0.9), rgba(26,26,46,0.9));
            color: #00ffff;
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            display: none;
            border: 3px solid #00ffff;
            box-shadow: 0 0 50px #00ffff;
            z-index: 2000;
        }
        
        #gameOver h2 {
            font-size: 36px;
            margin-bottom: 20px;
            text-shadow: 0 0 20px #00ffff;
        }
        
        #gameOver button {
            background: linear-gradient(135deg, #00ffff, #0088cc);
            color: #000;
            border: none;
            padding: 15px 30px;
            font-size: 18px;
            font-weight: bold;
            border-radius: 10px;
            cursor: pointer;
            margin-top: 20px;
            transition: all 0.3s ease;
        }
        
        #gameOver button:hover {
            background: linear-gradient(135deg, #00ccff, #0066aa);
            transform: scale(1.05);
            box-shadow: 0 0 20px #00ffff;
        }
        
        #minimap {
            position: absolute;
            bottom: 20px;
            left: 20px;
            width: 180px;
            height: 180px;
            background: rgba(0,0,0,0.8);
            border: 3px solid #00ffff;
            border-radius: 10px;
            box-shadow: 0 0 20px rgba(0,255,255,0.3);
        }
        
        #zoneTimer {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: #00ffff;
            font-size: 18px;
            font-weight: bold;
            text-shadow: 0 0 10px #00ffff;
            background: rgba(0,0,0,0.8);
            padding: 10px 20px;
            border-radius: 10px;
            border: 2px solid #00ffff;
            text-align: center;
        }
        
        #reloadIndicator {
            position: absolute;
            pointer-events: none;
            color: #ffff00;
            font-size: 14px;
            font-weight: bold;
            text-shadow: 0 0 5px #ffff00;
            background: rgba(0,0,0,0.7);
            padding: 5px 10px;
            border-radius: 5px;
            border: 1px solid #ffff00;
            display: none;
            z-index: 1000;
            transition: color 0.3s ease, border-color 0.3s ease, text-shadow 0.3s ease;
        }
        
        #instructions {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #00ffff;
            font-size: 12px;
            background: rgba(0,0,0,0.7);
            padding: 15px;
            border-radius: 10px;
            border: 2px solid #00ffff;
            text-shadow: 0 0 5px #00ffff;
            line-height: 1.4;
        }
        
        #loadingScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: linear-gradient(135deg, #0c0c0c 0%, #1a1a2e 50%, #16213e 100%);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: #00ffff;
            z-index: 3000;
        }
        
        #loadingScreen h1 {
            font-size: 48px;
            margin-bottom: 30px;
            text-shadow: 0 0 30px #00ffff;
            animation: glow 2s ease-in-out infinite alternate;
        }
        
        @keyframes glow {
            from { text-shadow: 0 0 20px #00ffff, 0 0 30px #00ffff, 0 0 40px #00ffff; }
            to { text-shadow: 0 0 30px #00ffff, 0 0 40px #00ffff, 0 0 50px #00ffff; }
        }
        
        .loading-bar {
            width: 400px;
            height: 20px;
            background: rgba(0,0,0,0.5);
            border: 2px solid #00ffff;
            border-radius: 10px;
            overflow: hidden;
            margin-bottom: 20px;
        }
        
        .loading-fill {
            height: 100%;
            background: linear-gradient(90deg, #00ffff, #0088cc);
            width: 0%;
            transition: width 0.3s ease;
            border-radius: 8px;
            box-shadow: 0 0 20px rgba(0,255,255,0.5);
        }
        
        .start-button {
            background: linear-gradient(135deg, #00ffff, #0088cc);
            color: #000;
            border: none;
            padding: 20px 40px;
            font-size: 24px;
            font-weight: bold;
            border-radius: 15px;
            cursor: pointer;
            margin-top: 30px;
            transition: all 0.3s ease;
            display: none;
        }
        
        .start-button:hover {
            background: linear-gradient(135deg, #00ccff, #0066aa);
            transform: scale(1.1);
            box-shadow: 0 0 30px #00ffff;
        }
        
        /* ë°˜ì‘í˜• ë””ìì¸ */
        @media (max-width: 768px) {
            #loadingScreen h1 {
                font-size: 32px;
                margin-bottom: 20px;
            }
            
            .loading-bar {
                width: 300px;
                height: 16px;
            }
            
            .start-button {
                padding: 15px 30px;
                font-size: 18px;
                margin-top: 20px;
            }
        }
        
        @media (max-width: 480px) {
            #loadingScreen h1 {
                font-size: 24px;
                margin-bottom: 15px;
            }
            
            .loading-bar {
                width: 250px;
                height: 14px;
            }
            
            .start-button {
                padding: 12px 24px;
                font-size: 16px;
                margin-top: 15px;
            }
        }
    </style>
</head>
<body>
    <div id="loadingScreen">
        <h1>FPS ë°°í‹€ë¡œì–„</h1>
        <p style="font-size: 18px; margin-bottom: 30px;">ìµœí›„ì˜ 1ì¸ì´ ë˜ì–´ë¼!</p>
        <div class="loading-bar">
            <div class="loading-fill" id="loadingFill"></div>
        </div>
        <p id="loadingText">ê²Œì„ ë¡œë”© ì¤‘...</p>
        <button class="start-button" id="startButton" onclick="startGame()">ê²Œì„ ì‹œì‘</button>
    </div>

    <div id="gameContainer" style="display: none;">
        <canvas id="gameCanvas" width="1200" height="800"></canvas>
        
        <div id="damageIndicator"></div>
        
        <div id="hud">
            <div id="currentWeapon">í˜„ì¬ ë¬´ê¸°: ì£¼ë¨¹</div>
            <div id="healthArmorSection">
                <div id="healthSection">
                    <div style="font-size: 14px; margin-bottom: 5px;">ì²´ë ¥: <span id="healthText">100</span>%</div>
                    <div id="healthBar"><div id="healthFill"></div></div>
                </div>
                <div id="armorSection">
                    <div style="font-size: 14px; margin-bottom: 5px;">ë°©ì–´êµ¬: <span id="armorText">0</span>% <span id="armorLevel"></span></div>
                    <div id="armorBar"><div id="armorFill"></div></div>
                </div>
            </div>
            <div id="dashCooldownSection" style="margin-top: 10px;">
                <div style="font-size: 12px; margin-bottom: 5px; text-align: center;">êµ¬ë¥´ê¸° ì¿¨íƒ€ì„</div>
                <div id="dashCooldownBar" style="width: 150px; height: 8px; background: rgba(0,0,0,0.8); border: 1px solid #00ffff; border-radius: 4px; overflow: hidden;">
                    <div id="dashCooldownFill" style="height: 100%; background: linear-gradient(90deg, #00ff00, #88ff88); width: 100%; transition: width 0.1s ease; border-radius: 3px;"></div>
                </div>
            </div>
        </div>
        
        <div id="inventoryInfo">
            <div id="inventoryDisplay"></div>
        </div>
        
        <div id="ammoInfo" style="position: absolute; bottom: 20px; left: 380px; color: #00ffff; font-size: 12px; font-weight: bold; text-shadow: 0 0 10px #00ffff; background: rgba(0,0,0,0.7); padding: 15px; border-radius: 10px; border: 2px solid #00ffff; min-width: 150px;">
            <div style="font-size: 14px; margin-bottom: 10px; color: #ffff00; text-align: center;">íƒ„ì•½ ë³´ìœ ëŸ‰</div>
            <div id="ammoTable"></div>
        </div>
        
        <canvas id="minimap" width="180" height="180"></canvas>
        
        <div id="zoneTimer">
            <div id="zoneStatus">ìê¸°ì¥ ëŒ€ê¸° ì¤‘...</div>
            <div id="zoneCountdown"></div>
        </div>
        
        <div id="reloadIndicator">ì¬ì¥ì „ ì¤‘...</div>
        
        <div id="fireDelayIndicator" style="position: absolute; pointer-events: none; color: #ff6600; font-size: 12px; font-weight: bold; text-shadow: 0 0 5px #ff6600; background: rgba(0,0,0,0.7); padding: 5px 10px; border-radius: 5px; border: 1px solid #ff6600; display: none; z-index: 1000;">
            ë°œì‚¬ ëŒ€ê¸° ì¤‘...
        </div>
        
        <div id="instructions">
            <strong>ğŸ® ì¡°ì‘ë²•</strong><br>
            WASD: ì´ë™ | Shift: ë‹¬ë¦¬ê¸°<br>
            Space/ë§ˆìš°ìŠ¤: ì‚¬ê²© | R: ì¬ì¥ì „<br>
            F: ì•„ì´í…œ íšë“ | Space: êµ¬ë¥´ê¸°<br>
            X: ì£¼ë¨¹ | 1,2: ë¬´ê¸° ì„ íƒ | 3: ìˆ˜ë¥˜íƒ„<br>
            Q: ë¬´ê¸° ë²„ë¦¬ê¸°<br><br>
            <strong>ğŸ† ìƒì¡´ì: <span id="aliveCount">16</span>ëª…</strong>
        </div>
        
        <div id="gameOver">
            <h2 id="gameResult">ê²Œì„ ì˜¤ë²„</h2>
            <p id="finalRank" style="font-size: 20px; margin: 10px 0;">ìˆœìœ„: -</p>
            <p id="finalStats" style="font-size: 16px; margin: 10px 0;">í‚¬: 0</p>
            <button onclick="location.reload()">ë‹¤ì‹œ ì‹œì‘</button>
        </div>
    </div>

    <script>
        // ë¡œë”© ì‹œìŠ¤í…œ
        let loadingProgress = 0;
        const loadingFill = document.getElementById('loadingFill');
        const loadingText = document.getElementById('loadingText');
        const startButton = document.getElementById('startButton');
        
        function updateLoading() {
            loadingProgress += Math.random() * 15 + 5;
            if (loadingProgress > 100) loadingProgress = 100;
            
            loadingFill.style.width = loadingProgress + '%';
            
            if (loadingProgress < 30) {
                loadingText.textContent = 'ë§µ ìƒì„± ì¤‘...';
            } else if (loadingProgress < 60) {
                loadingText.textContent = 'ì  AI ì´ˆê¸°í™” ì¤‘...';
            } else if (loadingProgress < 90) {
                loadingText.textContent = 'ì•„ì´í…œ ë°°ì¹˜ ì¤‘...';
            } else if (loadingProgress < 100) {
                loadingText.textContent = 'ìµœì¢… ì¤€ë¹„ ì¤‘...';
            } else {
                loadingText.textContent = 'ì¤€ë¹„ ì™„ë£Œ!';
                startButton.style.display = 'block';
                return;
            }
            
            setTimeout(updateLoading, 200 + Math.random() * 300);
        }
        
        updateLoading();
        
        function startGame() {
            document.getElementById('loadingScreen').style.display = 'none';
            document.getElementById('gameContainer').style.display = 'block';
            initGame();
        }
    </script>
</body>
</html>
    <script>
        // ê²Œì„ ë³€ìˆ˜ë“¤
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const minimapCanvas = document.getElementById('minimap');
        const minimapCtx = minimapCanvas.getContext('2d');
        
        // ìº”ë²„ìŠ¤ í¬ê¸°ë¥¼ ì „ì²´ í™”ë©´ìœ¼ë¡œ ì„¤ì •
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        
        let gameState = 'playing';
        let camera = { x: 0, y: 0 };
        let zoom = 1;
        
        const MAP_SIZE = 4000;
        
        // í”Œë ˆì´ì–´
        let player = {
            x: 0, // ì´ˆê¸°í™” í›„ ì•ˆì „í•œ ìœ„ì¹˜ë¡œ ì„¤ì •
            y: 0,
            angle: 0,
            health: 100,
            armor: 0,
            armorLevel: 0, // 0: ì—†ìŒ, 1: 1ë ˆë²¨, 2: 2ë ˆë²¨, 3: 3ë ˆë²¨
            currentWeapon: 'fist',
            weapons: { fist: { name: 'ì£¼ë¨¹', damage: 15, ammo: -1, maxAmmo: -1, fireRate: 1000, range: 50, autoFire: false } },
            inventory: [],
            // íƒ„ì•½ ì¸ë²¤í† ë¦¬ ì¶”ê°€
            ammoInventory: {
                rifle: 0,
                shotgun: 0,
                smg: 0,
                sniper: 0
            },
            speed: 3,
            size: 15,
            grenades: 0,
            kills: 0,
            lastShot: 0,
            showFireDelay: false, // ë°œì‚¬ ë”œë ˆì´ í‘œì‹œ ì—¬ë¶€
            fireDelayEndTime: 0, // ë°œì‚¬ ë”œë ˆì´ ì¢…ë£Œ ì‹œê°„
            isRunning: false,
            // ì¬ì¥ì „ ìƒíƒœ
            isReloading: false,
            reloadStartTime: 0,
            reloadDuration: 0,
            // êµ¬ë¥´ê¸° ê¸°ëŠ¥
            isDashing: false,
            dashStartTime: 0,
            dashDuration: 300, // 300ms êµ¬ë¥´ê¸°
            dashDistance: 150, // êµ¬ë¥´ê¸° ê±°ë¦¬ ì¦ê°€ (100 â†’ 150)
            dashCooldown: 3000, // 3ì´ˆ ì¿¨ë‹¤ìš´ (2000 â†’ 3000)
            lastDashTime: 0,
            dashStartX: 0,
            dashStartY: 0,
            dashTargetX: 0,
            dashTargetY: 0,
            // í€ì¹˜ ì• ë‹ˆë©”ì´ì…˜ ë³€ìˆ˜
            punchAnimation: {
                isActive: false,
                currentHand: 'right', // 'left' ë˜ëŠ” 'right'
                startTime: 0,
                duration: 300 // 300ms í€ì¹˜ ì• ë‹ˆë©”ì´ì…˜
            }
        };
        
        // í‚¤ ì…ë ¥
        let keys = {};
        let mouseX = 0, mouseY = 0;
        let mousePressed = false;
        
        // ê²Œì„ ê°ì²´ë“¤
        let bullets = [];
        let items = [];
        let enemies = [];
        let obstacles = [];
        let particles = [];
        let grenades = [];
        let houses = [];
        
        // ìê¸°ì¥ ì‹œìŠ¤í…œ
        let zone = {
            centerX: 0,
            centerY: 0,
            currentRadius: 0,
            targetRadius: 0,
            shrinkStartTime: 0,
            shrinkDuration: 30000, // 30ì´ˆ ë™ì•ˆ ì¶•ì†Œ
            phase: 0,
            maxPhases: 6,
            isActive: false,
            isShrinking: false,
            nextShrinkTime: 60000, // ì²« ì¶•ì†Œê¹Œì§€ 60ì´ˆ
            damagePerSecond: 2, // ì´ˆê¸° ë°ë¯¸ì§€
            lastDamageTime: 0,
            activationTime: 0, // ìê¸°ì¥ í™œì„±í™” ì‹œê°„
            // ë‹¤ìŒ ìê¸°ì¥ ì •ë³´
            nextCenterX: 0,
            nextCenterY: 0,
            nextRadius: 0,
            showNextZone: false
        };
        
        // ë¬´ê¸° ì •ì˜
        const weapons = {
            ar: { name: 'AR', damage: 35, ammo: 0, maxAmmo: 30, fireRate: 120, range: 600, ammoType: 'rifle', autoFire: true, reloadTime: 1000, bulletSpeed: 15 },
            shotgun: { name: 'ìƒ·ê±´', damage: 13, ammo: 0, maxAmmo: 5, fireRate: 800, range: 300, ammoType: 'shotgun', autoFire: false, reloadTime: 300, bulletSpeed: 18, shellReload: true, pellets: 8 },
            smg: { name: 'SMG', damage: 25, ammo: 0, maxAmmo: 25, fireRate: 80, range: 400, ammoType: 'smg', autoFire: true, reloadTime: 600, bulletSpeed: 20 },
            sr: { name: 'SR', damage: 90, ammo: 0, maxAmmo: 5, fireRate: 1200, range: 1000, ammoType: 'sniper', autoFire: false, zoomLevel: 2.0, reloadTime: 2000, bulletSpeed: 25 }
        };
        
        // ì•„ì´í…œ ì •ì˜
        const itemTypes = {
            weapon: { color: '#FFD700', size: 10 },
            ammo_rifle: { color: '#000000', size: 8 }, // AR íƒ„ì•½ (ê²€ì€ìƒ‰)
            ammo_shotgun: { color: '#8B4513', size: 8 }, // ìƒ·ê±´ íƒ„ì•½ (ê°ˆìƒ‰)
            ammo_smg: { color: '#00CED1', size: 8 }, // SMG íƒ„ì•½ (ì²­ë¡ìƒ‰)
            ammo_sniper: { color: '#D3D3D3', size: 8 }, // SR íƒ„ì•½ (ë°ì€ íšŒìƒ‰)
            armor1: { color: '#C0C0C0', size: 10 }, // 1ë ˆë²¨ ë°©ì–´êµ¬ (ë°ì€ íšŒìƒ‰)
            armor2: { color: '#808080', size: 10 }, // 2ë ˆë²¨ ë°©ì–´êµ¬ (íšŒìƒ‰)
            armor3: { color: '#2F2F2F', size: 10 }, // 3ë ˆë²¨ ë°©ì–´êµ¬ (ê²€ì€ìƒ‰)
            medkit: { color: '#32CD32', size: 10 },
            bandage: { color: '#90EE90', size: 8 },
            grenade: { color: '#8B0000', size: 6 }
        };
        
        // í”Œë ˆì´ì–´ê°€ ì§‘ ì•ˆì— ìˆëŠ”ì§€ í™•ì¸
        function isPlayerInHouse() {
            for (let house of houses) {
                if (player.x >= house.x && player.x <= house.x + house.width &&
                    player.y >= house.y && player.y <= house.y + house.height) {
                    return house;
                }
            }
            return null;
        }
        
        // ì´ˆê¸°í™”
        function initGame() {
            generateMap();
            spawnPlayerSafely();
            spawnEnemies();
            spawnItems();
            initializeZone();
            updateHUD();
            gameLoop();
        }
        
        // í”Œë ˆì´ì–´ ì•ˆì „ ìŠ¤í°
        function spawnPlayerSafely() {
            let attempts = 0;
            let spawnX, spawnY;
            
            do {
                spawnX = Math.random() * (MAP_SIZE - 200) + 100;
                spawnY = Math.random() * (MAP_SIZE - 200) + 100;
                attempts++;
            } while (attempts < 100 && isPositionBlocked(spawnX, spawnY, player.size));
            
            player.x = spawnX;
            player.y = spawnY;
        }
        
        // ìê¸°ì¥ ì´ˆê¸°í™”
        function initializeZone() {
            // ì²« ë²ˆì§¸ ìê¸°ì¥ ì¤‘ì‹¬ì€ ë§µ ì¤‘ì•™ ê·¼ì²˜
            zone.centerX = MAP_SIZE / 2 + (Math.random() - 0.5) * (MAP_SIZE * 0.3);
            zone.centerY = MAP_SIZE / 2 + (Math.random() - 0.5) * (MAP_SIZE * 0.3);
            
            // ì²« ìê¸°ì¥ì€ ë§µ ì „ì²´ë¥¼ ë®ì„ ë§Œí¼ í¬ê²Œ ì‹œì‘ (ë§µ ë°”ê¹¥ì—ì„œë¶€í„°)
            zone.currentRadius = MAP_SIZE * 0.8; // ë§µë³´ë‹¤ í° ë°˜ì§€ë¦„ìœ¼ë¡œ ì‹œì‘
            zone.targetRadius = MAP_SIZE * 0.4; // ì²« ë²ˆì§¸ ì¶•ì†Œ ëª©í‘œ
            zone.isActive = false; // ê²Œì„ ì‹œì‘ ì‹œì—ëŠ” ë¹„í™œì„±í™”
            zone.shrinkStartTime = Date.now() + 120000; // 2ë¶„ í›„ì— ì²« ë²ˆì§¸ ì¶•ì†Œ ì‹œì‘
            zone.activationTime = Date.now() + 60000; // 1ë¶„ í›„ì— ìê¸°ì¥ í™œì„±í™”
            
            // ë‹¤ìŒ ìê¸°ì¥ ìœ„ì¹˜ ë¯¸ë¦¬ ì„¤ì •
            generateNextZone();
        }
        
        // ë‹¤ìŒ ìê¸°ì¥ ìœ„ì¹˜ ìƒì„±
        function generateNextZone() {
            // ë‹¤ìŒ ìê¸°ì¥ ë°˜ì§€ë¦„ ê³„ì‚° (ë‹¨ê³„ë³„ë¡œ ì¶•ì†Œìœ¨ ì¡°ì •)
            let shrinkRatio = 0.7; // ê¸°ë³¸ ì¶•ì†Œìœ¨
            if (zone.phase >= 2) {
                shrinkRatio = 0.6; // 3ë‹¨ê³„ë¶€í„°ëŠ” ë” ì‘ê²Œ ì¶•ì†Œ
            }
            if (zone.phase >= 4) {
                shrinkRatio = 0.5; // 5ë‹¨ê³„ë¶€í„°ëŠ” ë”ìš± ì‘ê²Œ ì¶•ì†Œ
            }
            
            zone.nextRadius = Math.max(80, zone.currentRadius * shrinkRatio);
            
            // í˜„ì¬ ìê¸°ì¥ ë‚´ì—ì„œë§Œ ë‹¤ìŒ ìê¸°ì¥ ì¤‘ì‹¬ì´ ìœ„ì¹˜í•  ìˆ˜ ìˆë„ë¡ ì œí•œ
            const maxDistanceFromCenter = zone.currentRadius - zone.nextRadius;
            
            // ëœë¤í•œ ê°ë„ì™€ ê±°ë¦¬ë¡œ ë‹¤ìŒ ìê¸°ì¥ ì¤‘ì‹¬ ê²°ì •
            const angle = Math.random() * Math.PI * 2;
            const distance = Math.random() * maxDistanceFromCenter;
            
            zone.nextCenterX = zone.centerX + Math.cos(angle) * distance;
            zone.nextCenterY = zone.centerY + Math.sin(angle) * distance;
            
            // ë§µ ê²½ê³„ ë‚´ë¡œ ì¶”ê°€ ì œí•œ (ì•ˆì „ì¥ì¹˜)
            const margin = zone.nextRadius + 50;
            zone.nextCenterX = Math.max(margin, Math.min(MAP_SIZE - margin, zone.nextCenterX));
            zone.nextCenterY = Math.max(margin, Math.min(MAP_SIZE - margin, zone.nextCenterY));
            
            zone.showNextZone = true;
        }
        
        // ë§µ ìƒì„±
        function generateMap() {
            // ì§‘ ìƒì„± (ì¥ì‹ìš©, í†µê³¼ ê°€ëŠ¥)
            for (let i = 0; i < 15; i++) { // ê°œìˆ˜ë¥¼ ì¤„ì´ê³  í¬ê¸°ë¥¼ í‚¤ì›€
                const houseX = Math.random() * (MAP_SIZE - 300) + 150;
                const houseY = Math.random() * (MAP_SIZE - 300) + 150;
                const houseWidth = 120 + Math.random() * 80; // ë” í° í¬ê¸°
                const houseHeight = 120 + Math.random() * 80; // ë” í° í¬ê¸°
                
                houses.push({
                    x: houseX,
                    y: houseY,
                    width: houseWidth,
                    height: houseHeight,
                    doorX: houseX + houseWidth / 2 - 15,
                    doorY: houseY + houseHeight,
                    doorWidth: 30,
                    doorHeight: 8
                });
            }
            
            // ë‚˜ë¬´ ìƒì„±
            for (let i = 0; i < 200; i++) {
                let treeX, treeY;
                let attempts = 0;
                
                do {
                    treeX = Math.random() * (MAP_SIZE - 40);
                    treeY = Math.random() * (MAP_SIZE - 40);
                    attempts++;
                } while (attempts < 50 && isNearHouse(treeX, treeY, 50));
                
                obstacles.push({
                    x: treeX,
                    y: treeY,
                    width: 20 + Math.random() * 20,
                    height: 20 + Math.random() * 20,
                    type: 'tree',
                    color: '#228B22'
                });
            }
            
            // ë°”ìœ„ ìƒì„±
            for (let i = 0; i < 100; i++) {
                let rockX, rockY;
                let attempts = 0;
                
                do {
                    rockX = Math.random() * (MAP_SIZE - 60);
                    rockY = Math.random() * (MAP_SIZE - 60);
                    attempts++;
                } while (attempts < 50 && isNearHouse(rockX, rockY, 50));
                
                obstacles.push({
                    x: rockX,
                    y: rockY,
                    width: 30 + Math.random() * 30,
                    height: 30 + Math.random() * 30,
                    type: 'rock',
                    color: '#696969'
                });
            }
        }
        
        // ì§‘ ê·¼ì²˜ì¸ì§€ í™•ì¸
        function isNearHouse(x, y, distance) {
            for (let house of houses) {
                if (x > house.x - distance && x < house.x + house.width + distance &&
                    y > house.y - distance && y < house.y + house.height + distance) {
                    return true;
                }
            }
            return false;
        }
        
        // ì  ìŠ¤í°
        function spawnEnemies() {
            for (let i = 0; i < 15; i++) {
                let spawnX, spawnY;
                let attempts = 0;
                
                do {
                    spawnX = Math.random() * (MAP_SIZE - 30) + 15;
                    spawnY = Math.random() * (MAP_SIZE - 30) + 15;
                    attempts++;
                } while (attempts < 50 && isPositionBlocked(spawnX, spawnY, 15));
                
                enemies.push({
                    x: spawnX,
                    y: spawnY,
                    angle: Math.random() * Math.PI * 2,
                    health: 100,
                    armor: 0,
                    armorLevel: 0, // ë°©ì–´êµ¬ ë ˆë²¨ ì¶”ê°€
                    weapon: null,
                    speed: 1.5 + Math.random() * 1,
                    size: 15,
                    lastShot: 0,
                    target: null,
                    grenades: Math.random() < 0.3 ? 1 + Math.floor(Math.random() * 2) : 0,
                    healthItems: Math.random() < 0.4 ? 1 + Math.floor(Math.random() * 2) : 0,
                    // AI íƒ„ì•½ ì¸ë²¤í† ë¦¬ ì¶”ê°€
                    ammoInventory: {
                        rifle: Math.floor(Math.random() * 60),
                        shotgun: Math.floor(Math.random() * 20),
                        smg: Math.floor(Math.random() * 60),
                        sniper: Math.floor(Math.random() * 30)
                    },
                    isUsingHealthItem: false,
                    healthItemStartTime: 0,
                    // í€ì¹˜ ì• ë‹ˆë©”ì´ì…˜ ë³€ìˆ˜
                    punchAnimation: {
                        isActive: false,
                        currentHand: 'right',
                        startTime: 0,
                        duration: 300
                    },
                    ai: {
                        state: 'patrol',
                        lastStateChange: 0,
                        patrolTarget: { x: Math.random() * MAP_SIZE, y: Math.random() * MAP_SIZE },
                        farmingTarget: null,
                        fleeTimer: 0,
                        aggressionLevel: Math.random() * 0.8 + 0.2,
                        lastPlayerSeen: 0,
                        searchTimer: 0,
                        moveTimer: 0,
                        lastGrenadeThrow: 0
                    }
                });
            }
        }
        
        // ì•„ì´í…œ ìŠ¤í°
        function spawnItems() {
            // ì§‘ ì•ˆì—ë§Œ ì•„ì´í…œ ìŠ¤í° (100%)
            houses.forEach(house => {
                const itemsInHouse = 8 + Math.floor(Math.random() * 6); // ë” ë§ì€ ì•„ì´í…œ
                
                for (let i = 0; i < itemsInHouse; i++) {
                    const spawnX = house.x + 20 + Math.random() * (house.width - 40);
                    const spawnY = house.y + 20 + Math.random() * (house.height - 40);
                    
                    const types = ['weapon', 'ammo', 'armor1', 'armor2', 'armor3', 'medkit', 'bandage', 'grenade'];
                    const weights = [0.2, 0.35, 0.05, 0.05, 0.05, 0.1, 0.15, 0.05]; // íƒ„ì•½ ë¹„ì¤‘ ì¦ê°€
                    const type = weightedRandom(types, weights);
                    
                    let data = {};
                    let itemType = type;
                    if (type === 'weapon') {
                        const weaponTypes = Object.keys(weapons);
                        data.weaponType = weaponTypes[Math.floor(Math.random() * weaponTypes.length)];
                    } else if (type === 'ammo') {
                        const ammoTypes = ['rifle', 'shotgun', 'smg', 'sniper'];
                        const selectedAmmoType = ammoTypes[Math.floor(Math.random() * ammoTypes.length)];
                        data.ammoType = selectedAmmoType;
                        
                        // íƒ„ì•½ íƒ€ì…ë³„ ê°œìˆ˜ ì„¤ì •
                        if (selectedAmmoType === 'rifle') {
                            data.amount = 30;
                            itemType = 'ammo_rifle';
                        } else if (selectedAmmoType === 'shotgun') {
                            data.amount = 10;
                            itemType = 'ammo_shotgun';
                        } else if (selectedAmmoType === 'smg') {
                            data.amount = 30;
                            itemType = 'ammo_smg';
                        } else if (selectedAmmoType === 'sniper') {
                            data.amount = 15;
                            itemType = 'ammo_sniper';
                        }
                    } else if (type === 'armor1') {
                        data.level = 1;
                        data.maxArmor = 30;
                        data.currentArmor = 30; // ìƒˆ ë°©ì–´êµ¬ëŠ” ìµœëŒ€ ë‚´êµ¬ë„
                    } else if (type === 'armor2') {
                        data.level = 2;
                        data.maxArmor = 60;
                        data.currentArmor = 60; // ìƒˆ ë°©ì–´êµ¬ëŠ” ìµœëŒ€ ë‚´êµ¬ë„
                    } else if (type === 'armor3') {
                        data.level = 3;
                        data.maxArmor = 100;
                        data.currentArmor = 100; // ìƒˆ ë°©ì–´êµ¬ëŠ” ìµœëŒ€ ë‚´êµ¬ë„
                    } else if (type === 'medkit') {
                        data.amount = 75;
                        data.healTime = 3000;
                    } else if (type === 'bandage') {
                        data.amount = 25;
                        data.healTime = 1000;
                    } else if (type === 'grenade') {
                        data.amount = 1 + Math.floor(Math.random() * 2);
                    }
                    
                    items.push({
                        x: spawnX,
                        y: spawnY,
                        type: itemType,
                        data: data,
                        ...itemTypes[itemType]
                    });
                }
            });
        }
        
        // ê°€ì¤‘ì¹˜ ê¸°ë°˜ ëœë¤ ì„ íƒ
        function weightedRandom(items, weights) {
            const totalWeight = weights.reduce((sum, weight) => sum + weight, 0);
            let random = Math.random() * totalWeight;
            
            for (let i = 0; i < items.length; i++) {
                random -= weights[i];
                if (random <= 0) {
                    return items[i];
                }
            }
            return items[items.length - 1];
        }
    </script>
    <script>
        // ì¶©ëŒ ê°ì§€ ë° ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜ë“¤
        function checkCollision(obj1, obj2) {
            return obj1.x < obj2.x + obj2.width &&
                   obj1.x + obj1.size > obj2.x &&
                   obj1.y < obj2.y + obj2.height &&
                   obj1.y + obj1.size > obj2.y;
        }
        
        function isPositionBlocked(x, y, size) {
            for (let obstacle of obstacles) {
                if (x - size < obstacle.x + obstacle.width &&
                    x + size > obstacle.x &&
                    y - size < obstacle.y + obstacle.height &&
                    y + size > obstacle.y) {
                    return true;
                }
            }
            return false;
        }
        
        function canMoveTo(x, y, size) {
            if (x - size < 0 || x + size > MAP_SIZE || y - size < 0 || y + size > MAP_SIZE) {
                return false;
            }
            return !isPositionBlocked(x, y, size);
        }
        
        function distance(obj1, obj2) {
            return Math.sqrt((obj1.x - obj2.x) ** 2 + (obj1.y - obj2.y) ** 2);
        }
        
        function angleTo(from, to) {
            return Math.atan2(to.y - from.y, to.x - from.x);
        }
        
        // ìê¸°ì¥ íƒ€ì´ë¨¸ ì—…ë°ì´íŠ¸
        function updateZoneTimer() {
            const now = Date.now();
            const zoneStatus = document.getElementById('zoneStatus');
            const zoneCountdown = document.getElementById('zoneCountdown');
            
            if (!zone.isActive) {
                // ìê¸°ì¥ í™œì„±í™” ì „
                const timeToActivation = Math.max(0, zone.activationTime - now);
                const seconds = Math.ceil(timeToActivation / 1000);
                
                zoneStatus.textContent = 'ìê¸°ì¥ í™œì„±í™”ê¹Œì§€';
                zoneCountdown.textContent = `${seconds}ì´ˆ`;
                zoneCountdown.style.color = '#ffff00';
            } else if (!zone.isShrinking) {
                // ìê¸°ì¥ ì¶•ì†Œ ëŒ€ê¸° ì¤‘
                const timeToShrink = Math.max(0, zone.shrinkStartTime - now);
                const seconds = Math.ceil(timeToShrink / 1000);
                
                zoneStatus.textContent = `ìê¸°ì¥ ì¶•ì†Œê¹Œì§€ (${zone.phase + 1}ë‹¨ê³„)`;
                zoneCountdown.textContent = `${seconds}ì´ˆ`;
                zoneCountdown.style.color = '#ff8800';
            } else {
                // ìê¸°ì¥ ì¶•ì†Œ ì¤‘
                const timeRemaining = Math.max(0, zone.shrinkStartTime + zone.shrinkDuration - now);
                const seconds = Math.ceil(timeRemaining / 1000);
                const speedText = zone.phase >= 3 ? ' (ê³ ì†)' : zone.phase >= 1 ? ' (ê°€ì†)' : '';
                
                zoneStatus.textContent = `ìê¸°ì¥ ì¶•ì†Œ ì¤‘! (${zone.phase + 1}ë‹¨ê³„)${speedText}`;
                zoneCountdown.textContent = `${seconds}ì´ˆ`;
                zoneCountdown.style.color = '#ff0000';
            }
        }
        
        // ì¬ì¥ì „ ì·¨ì†Œ í•¨ìˆ˜
        function cancelReload() {
            if (!player.isReloading) return false;
            
            player.isReloading = false;
            document.getElementById('reloadIndicator').style.display = 'none';
            
            // ì¬ì¥ì „ ì·¨ì†Œ ë©”ì‹œì§€ í‘œì‹œ
            showReloadCancelMessage();
            
            return true;
        }
        
        // ì¬ì¥ì „ ì·¨ì†Œ ë©”ì‹œì§€ í‘œì‹œ í•¨ìˆ˜
        function showReloadCancelMessage() {
            const reloadIndicator = document.getElementById('reloadIndicator');
            
            reloadIndicator.style.display = 'block';
            reloadIndicator.style.left = (mouseX + 20) + 'px';
            reloadIndicator.style.top = (mouseY - 30) + 'px';
            reloadIndicator.textContent = 'ì¥ì „ ì·¨ì†Œë¨!';
            reloadIndicator.style.color = '#ff6600';
            reloadIndicator.style.borderColor = '#ff6600';
            reloadIndicator.style.textShadow = '0 0 5px #ff6600';
            
            // 1ì´ˆ í›„ ë©”ì‹œì§€ ìˆ¨ê¹€
            setTimeout(() => {
                if (reloadIndicator.textContent === 'ì¥ì „ ì·¨ì†Œë¨!') {
                    reloadIndicator.style.display = 'none';
                    // ìƒ‰ìƒì„ ê¸°ë³¸ê°’ìœ¼ë¡œ ë³µì›
                    reloadIndicator.style.color = '#ffff00';
                    reloadIndicator.style.borderColor = '#ffff00';
                    reloadIndicator.style.textShadow = '0 0 5px #ffff00';
                }
            }, 1000);
        }
        
        // ì¬ì¥ì „ í•¨ìˆ˜
        function startReload(weaponKey) {
            if (player.isReloading || weaponKey === 'fist' || weaponKey === 'grenade') return;
            
            const weapon = player.weapons[weaponKey];
            const weaponData = weapons[weaponKey];
            
            if (!weapon || !weaponData || weapon.ammo >= weapon.maxAmmo) return;
            
            // ì¸ë²¤í† ë¦¬ì— í•´ë‹¹ íƒ„ì•½ì´ ìˆëŠ”ì§€ í™•ì¸
            const ammoType = weaponData.ammoType;
            if (!player.ammoInventory[ammoType] || player.ammoInventory[ammoType] <= 0) {
                // íƒ„ì•½ì´ ì—†ìœ¼ë©´ ì¬ì¥ì „ ë¶ˆê°€
                return;
            }
            
            player.isReloading = true;
            player.reloadStartTime = Date.now();
            
            if (weaponData.shellReload) {
                // ìƒ·ê±´ì€ 1ë°œì”© ì¥ì „
                player.reloadDuration = weaponData.reloadTime;
            } else {
                // ë‹¤ë¥¸ ë¬´ê¸°ëŠ” ì „ì²´ ì¬ì¥ì „
                player.reloadDuration = weaponData.reloadTime;
            }
        }
        
        // ì¬ì¥ì „ ì—…ë°ì´íŠ¸
        function updateReload() {
            if (!player.isReloading) {
                document.getElementById('reloadIndicator').style.display = 'none';
                return;
            }
            
            const elapsed = Date.now() - player.reloadStartTime;
            const weapon = player.weapons[player.currentWeapon];
            const weaponData = weapons[player.currentWeapon];
            
            if (!weapon || !weaponData) {
                player.isReloading = false;
                document.getElementById('reloadIndicator').style.display = 'none';
                return;
            }
            
            // ë§ˆìš°ìŠ¤ ì˜†ì— ì¬ì¥ì „ í‘œì‹œ
            const reloadIndicator = document.getElementById('reloadIndicator');
            const progress = Math.min(elapsed / player.reloadDuration, 1);
            const percentage = Math.floor(progress * 100);
            
            reloadIndicator.style.display = 'block';
            reloadIndicator.style.left = (mouseX + 20) + 'px';
            reloadIndicator.style.top = (mouseY - 30) + 'px';
            reloadIndicator.textContent = `ì¬ì¥ì „ ì¤‘... ${percentage}%`;
            
            // ì¬ì¥ì „ ì¤‘ì¼ ë•ŒëŠ” ê¸°ë³¸ ìƒ‰ìƒ (ë…¸ë€ìƒ‰) ì‚¬ìš©
            reloadIndicator.style.color = '#ffff00';
            reloadIndicator.style.borderColor = '#ffff00';
            reloadIndicator.style.textShadow = '0 0 5px #ffff00';
            
            if (elapsed >= player.reloadDuration) {
                const ammoType = weaponData.ammoType;
                
                if (weaponData.shellReload) {
                    // ìƒ·ê±´: 1ë°œ ì¶”ê°€
                    if (player.ammoInventory[ammoType] > 0) {
                        weapon.ammo = Math.min(weapon.maxAmmo, weapon.ammo + 1);
                        player.ammoInventory[ammoType]--;
                        
                        if (weapon.ammo < weapon.maxAmmo && player.ammoInventory[ammoType] > 0) {
                            // ê³„ì† ì¬ì¥ì „ (íƒ„ì•½ì´ ìˆì„ ë•Œë§Œ)
                            player.reloadStartTime = Date.now();
                        } else {
                            // ì¬ì¥ì „ ì™„ë£Œ (íƒ„ì•½ ë¶€ì¡±í•˜ê±°ë‚˜ ê°€ë“ì°¸)
                            player.isReloading = false;
                            reloadIndicator.style.display = 'none';
                        }
                    } else {
                        // íƒ„ì•½ ë¶€ì¡±ìœ¼ë¡œ ì¬ì¥ì „ ì¤‘ë‹¨
                        player.isReloading = false;
                        reloadIndicator.style.display = 'none';
                    }
                } else {
                    // ë‹¤ë¥¸ ë¬´ê¸°: ì „ì²´ ì¬ì¥ì „
                    const neededAmmo = weapon.maxAmmo - weapon.ammo;
                    const availableAmmo = Math.min(neededAmmo, player.ammoInventory[ammoType]);
                    
                    weapon.ammo += availableAmmo;
                    player.ammoInventory[ammoType] -= availableAmmo;
                    
                    player.isReloading = false;
                    reloadIndicator.style.display = 'none';
                }
            }
        }
        
        // ë°œì‚¬ ë”œë ˆì´ í‘œì‹œ ì—…ë°ì´íŠ¸
        function updateFireDelayIndicator() {
            const fireDelayIndicator = document.getElementById('fireDelayIndicator');
            const now = Date.now();
            
            if (player.showFireDelay && now < player.fireDelayEndTime) {
                const remainingTime = Math.ceil((player.fireDelayEndTime - now) / 1000 * 10) / 10; // 0.1ì´ˆ ë‹¨ìœ„
                
                fireDelayIndicator.style.display = 'block';
                fireDelayIndicator.style.left = (mouseX + 20) + 'px';
                fireDelayIndicator.style.top = (mouseY - 50) + 'px';
                
                // í˜„ì¬ ë¬´ê¸°ì˜ íƒ„ì•½ ìƒíƒœ í™•ì¸
                const currentWeapon = player.weapons[player.currentWeapon];
                if (currentWeapon && currentWeapon.ammo <= 0 && currentWeapon.ammo !== -1) {
                    fireDelayIndicator.textContent = 'íƒ„ì•½ ì—†ìŒ!';
                    fireDelayIndicator.style.color = '#ff0000';
                    fireDelayIndicator.style.borderColor = '#ff0000';
                } else {
                    fireDelayIndicator.textContent = `ë°œì‚¬ ëŒ€ê¸° ì¤‘... ${remainingTime.toFixed(1)}ì´ˆ`;
                    fireDelayIndicator.style.color = '#ff6600';
                    fireDelayIndicator.style.borderColor = '#ff6600';
                }
            } else {
                fireDelayIndicator.style.display = 'none';
                player.showFireDelay = false;
            }
        }
        
        // êµ¬ë¥´ê¸° ì—…ë°ì´íŠ¸ í•¨ìˆ˜
        function updateDash() {
            if (player.isDashing) {
                const elapsed = Date.now() - player.dashStartTime;
                const progress = Math.min(elapsed / player.dashDuration, 1);
                
                if (progress >= 1) {
                    player.isDashing = false;
                    player.x = player.dashTargetX;
                    player.y = player.dashTargetY;
                } else {
                    // ë¶€ë“œëŸ¬ìš´ ì´ë™ (easeOut)
                    const easeProgress = 1 - Math.pow(1 - progress, 3);
                    player.x = player.dashStartX + (player.dashTargetX - player.dashStartX) * easeProgress;
                    player.y = player.dashStartY + (player.dashTargetY - player.dashStartY) * easeProgress;
                }
            }
        }
        
        // êµ¬ë¥´ê¸° ì‹œì‘ í•¨ìˆ˜
        function startDash() {
            const now = Date.now();
            if (player.isDashing || now - player.lastDashTime < player.dashCooldown) {
                return false;
            }
            
            // ì´ë™ ë°©í–¥ ê³„ì‚°
            let moveX = 0, moveY = 0;
            if (keys['w']) moveY -= 1;
            if (keys['s']) moveY += 1;
            if (keys['a']) moveX -= 1;
            if (keys['d']) moveX += 1;
            
            // ì´ë™ í‚¤ê°€ ëˆŒë ¤ìˆì§€ ì•Šìœ¼ë©´ ë§ˆìš°ìŠ¤ ë°©í–¥ìœ¼ë¡œ
            if (moveX === 0 && moveY === 0) {
                const worldMouseX = mouseX + camera.x;
                const worldMouseY = mouseY + camera.y;
                const angle = Math.atan2(worldMouseY - player.y, worldMouseX - player.x);
                moveX = Math.cos(angle);
                moveY = Math.sin(angle);
            } else {
                // ë°©í–¥ ì •ê·œí™”
                const length = Math.sqrt(moveX * moveX + moveY * moveY);
                moveX /= length;
                moveY /= length;
            }
            
            // ëª©í‘œ ìœ„ì¹˜ ê³„ì‚°
            const targetX = player.x + moveX * player.dashDistance;
            const targetY = player.y + moveY * player.dashDistance;
            
            // ëª©í‘œ ìœ„ì¹˜ê°€ ìœ íš¨í•œì§€ í™•ì¸
            if (canMoveTo(targetX, targetY, player.size)) {
                player.isDashing = true;
                player.dashStartTime = now;
                player.lastDashTime = now;
                player.dashStartX = player.x;
                player.dashStartY = player.y;
                player.dashTargetX = targetX;
                player.dashTargetY = targetY;
                return true;
            }
            
            return false;
        }
        
        // ì´ì•Œ ë°œì‚¬
        function shoot(shooter, targetX, targetY) {
            // ìˆ˜ë¥˜íƒ„ ì²˜ë¦¬ (ì¡°ê¸° ë°˜í™˜)
            if (shooter === player && shooter.currentWeapon === 'grenade') {
                if (shooter.grenades > 0) {
                    throwGrenade(shooter, targetX, targetY);
                }
                return;
            }
            
            let weapon;
            if (shooter === player) {
                weapon = shooter.weapons[shooter.currentWeapon];
                if (!weapon) return;
                
                const now = Date.now();
                const timeSinceLastShot = now - shooter.lastShot;
                
                if (timeSinceLastShot < weapon.fireRate) {
                    // SRê³¼ ìƒ·ê±´ì˜ ê²½ìš° ë°œì‚¬ ë”œë ˆì´ í‘œì‹œ
                    if ((shooter.currentWeapon === 'sr' || shooter.currentWeapon === 'shotgun') && weapon.ammo > 0) {
                        shooter.showFireDelay = true;
                        shooter.fireDelayEndTime = shooter.lastShot + weapon.fireRate;
                    }
                    return;
                }
                
                // ë°œì‚¬ ê°€ëŠ¥í•  ë•Œ ë”œë ˆì´ í‘œì‹œ í•´ì œ
                shooter.showFireDelay = false;
                
                // ì£¼ë¨¹ ê³µê²© ì‹œ í€ì¹˜ ì• ë‹ˆë©”ì´ì…˜ íŠ¸ë¦¬ê±°
                if (shooter.currentWeapon === 'fist') {
                    shooter.punchAnimation.isActive = true;
                    shooter.punchAnimation.startTime = Date.now();
                    shooter.punchAnimation.currentHand = shooter.punchAnimation.currentHand === 'left' ? 'right' : 'left';
                }
            } else {
                if (!shooter.weapon) {
                    // ì ì´ ë¬´ê¸°ê°€ ì—†ì„ ë•Œ ì£¼ë¨¹ ê³µê²©
                    weapon = { name: 'ì£¼ë¨¹', damage: 15, ammo: -1, fireRate: 1200, range: 50 };
                    if (Date.now() - shooter.lastShot < weapon.fireRate) return;
                    
                    // ì  ì£¼ë¨¹ ê³µê²© ì‹œ í€ì¹˜ ì• ë‹ˆë©”ì´ì…˜ íŠ¸ë¦¬ê±°
                    shooter.punchAnimation.isActive = true;
                    shooter.punchAnimation.startTime = Date.now();
                    shooter.punchAnimation.currentHand = shooter.punchAnimation.currentHand === 'left' ? 'right' : 'left';
                } else {
                    weapon = weapons[shooter.weapon];
                    if (!weapon || Date.now() - shooter.lastShot < weapon.fireRate) return;
                }
            }
            
            const angle = Math.atan2(targetY - shooter.y, targetX - shooter.x);
            
            // ì£¼ë¨¹ ê³µê²© ì²˜ë¦¬ (ê·¼ì ‘ ê³µê²©)
            if ((shooter === player && shooter.currentWeapon === 'fist') || 
                (shooter !== player && !shooter.weapon)) {
                
                const actualRange = 50; // ì£¼ë¨¹ ê³µê²© ë²”ìœ„ë¥¼ 50ìœ¼ë¡œ ì„¤ì •
                
                // í”Œë ˆì´ì–´ê°€ ì£¼ë¨¹ìœ¼ë¡œ ê³µê²©í•˜ëŠ” ê²½ìš°
                if (shooter === player) {
                    let hitSomething = false;
                    for (let i = enemies.length - 1; i >= 0; i--) {
                        const enemy = enemies[i];
                        const distToEnemy = Math.sqrt((enemy.x - shooter.x) ** 2 + (enemy.y - shooter.y) ** 2);
                        
                        // ì ì´ ì£¼ë¨¹ ë²”ìœ„ ë‚´ì— ìˆê³ , í”Œë ˆì´ì–´ê°€ ì  ë°©í–¥ì„ í–¥í•˜ê³  ìˆëŠ”ì§€ í™•ì¸
                        if (distToEnemy <= actualRange) {
                            const angleToEnemy = Math.atan2(enemy.y - shooter.y, enemy.x - shooter.x);
                            const angleDiff = Math.abs(angle - angleToEnemy);
                            const normalizedAngleDiff = Math.min(angleDiff, 2 * Math.PI - angleDiff);
                            
                            // 45ë„ ë²”ìœ„ ë‚´ì—ì„œë§Œ ê³µê²© ê°€ëŠ¥
                            if (normalizedAngleDiff <= Math.PI / 4) {
                                const isDead = takeDamage(enemy, weapon.damage);
                                hitSomething = true;
                                
                                // ì£¼ë¨¹ íˆíŠ¸ íŒŒí‹°í´ íš¨ê³¼
                                createBloodParticles(enemy.x, enemy.y);
                                
                                if (isDead) {
                                    // ì  ì‚¬ë§ ì²˜ë¦¬
                                    enemies.splice(i, 1);
                                    player.kills++;
                                    
                                    // ì•„ì´í…œ ë“œë¡­
                                    if (enemy.weapon) {
                                        // ë¬´ê¸° ë“œë¡­
                                        items.push({
                                            x: enemy.x + (Math.random() - 0.5) * 30,
                                            y: enemy.y + (Math.random() - 0.5) * 30,
                                            type: 'weapon',
                                            data: { weaponType: enemy.weapon },
                                            ...itemTypes.weapon
                                        });
                                        
                                        // ë¬´ê¸°ì— ë‚¨ì€ íƒ„ì•½ ë“œë¡­
                                        const weaponData = weapons[enemy.weapon];
                                        if (weaponData && weaponData.ammo > 0) {
                                            const ammoType = `ammo_${weaponData.ammoType}`;
                                            items.push({
                                                x: enemy.x + (Math.random() - 0.5) * 30,
                                                y: enemy.y + (Math.random() - 0.5) * 30,
                                                type: ammoType,
                                                data: { 
                                                    ammoType: weaponData.ammoType,
                                                    amount: weaponData.ammo 
                                                },
                                                ...itemTypes[ammoType]
                                            });
                                        }
                                    }
                                    if (enemy.armor > 0) {
                                        items.push({
                                            x: enemy.x + (Math.random() - 0.5) * 30,
                                            y: enemy.y + (Math.random() - 0.5) * 30,
                                            type: 'armor',
                                            data: { amount: Math.floor(enemy.armor / 2) }
                                        });
                                    }
                                    if (enemy.grenades > 0) {
                                        items.push({
                                            x: enemy.x + (Math.random() - 0.5) * 30,
                                            y: enemy.y + (Math.random() - 0.5) * 30,
                                            type: 'grenade',
                                            data: { amount: enemy.grenades }
                                        });
                                    }
                                }
                                break; // í•œ ë²ˆì— í•˜ë‚˜ì˜ ì ë§Œ ê³µê²©
                            }
                        }
                    }
                } 
                // ì ì´ ì£¼ë¨¹ìœ¼ë¡œ ê³µê²©í•˜ëŠ” ê²½ìš°
                else {
                    // í”Œë ˆì´ì–´ ê³µê²©
                    const distToPlayer = Math.sqrt((player.x - shooter.x) ** 2 + (player.y - shooter.y) ** 2);
                    if (distToPlayer <= actualRange) {
                        const angleToPlayer = Math.atan2(player.y - shooter.y, player.x - shooter.x);
                        const angleDiff = Math.abs(shooter.angle - angleToPlayer);
                        const normalizedAngleDiff = Math.min(angleDiff, 2 * Math.PI - angleDiff);
                        
                        // 45ë„ ë²”ìœ„ ë‚´ì—ì„œë§Œ ê³µê²© ê°€ëŠ¥
                        if (normalizedAngleDiff <= Math.PI / 4) {
                            const playerDead = takeDamage(player, weapon.damage);
                            
                            // ì£¼ë¨¹ íˆíŠ¸ íŒŒí‹°í´ íš¨ê³¼
                            createBloodParticles(player.x, player.y);
                            
                            if (playerDead) {
                                gameState = 'gameOver';
                            }
                        }
                    }
                    
                    // ë‹¤ë¥¸ ì ë“¤ì—ê²Œë„ ê³µê²©
                    for (let i = enemies.length - 1; i >= 0; i--) {
                        const enemy = enemies[i];
                        if (enemy !== shooter) {
                            const distToEnemy = Math.sqrt((enemy.x - shooter.x) ** 2 + (enemy.y - shooter.y) ** 2);
                            if (distToEnemy <= actualRange) {
                                const angleToEnemy = Math.atan2(enemy.y - shooter.y, enemy.x - shooter.x);
                                const angleDiff = Math.abs(shooter.angle - angleToEnemy);
                                const normalizedAngleDiff = Math.min(angleDiff, 2 * Math.PI - angleDiff);
                                
                                // 45ë„ ë²”ìœ„ ë‚´ì—ì„œë§Œ ê³µê²© ê°€ëŠ¥
                                if (normalizedAngleDiff <= Math.PI / 4) {
                                    const isDead = takeDamage(enemy, weapon.damage);
                                    
                                    // ì£¼ë¨¹ íˆíŠ¸ íŒŒí‹°í´ íš¨ê³¼
                                    createBloodParticles(enemy.x, enemy.y);
                                    
                                    if (isDead) {
                                        enemies.splice(i, 1);
                                    }
                                    break; // í•œ ë²ˆì— í•˜ë‚˜ì˜ ì ë§Œ ê³µê²©
                                }
                            }
                        }
                    }
                }
                return; // ì£¼ë¨¹ ê³µê²©ì€ ì´ì•Œì„ ìƒì„±í•˜ì§€ ì•ŠìŒ
            }
            
            // íƒ„ì•½ ì²´í¬ (ì£¼ë¨¹ ì œì™¸)
            if (weapon.ammo !== -1 && weapon.ammo <= 0) {
                // íƒ„ì•½ì´ ì—†ìœ¼ë©´ ë°œì‚¬ ë¶ˆê°€
                if (shooter === player && (shooter.currentWeapon === 'sr' || shooter.currentWeapon === 'shotgun')) {
                    // íƒ„ì•½ ë¶€ì¡± í‘œì‹œ
                    shooter.showFireDelay = true;
                    shooter.fireDelayEndTime = Date.now() + 1000; // 1ì´ˆê°„ "íƒ„ì•½ ì—†ìŒ" í‘œì‹œ
                }
                return;
            }
            
            if (weapon.ammo !== -1) weapon.ammo--;
            
            if (shooter === player) {
                const now = Date.now();
                shooter.lastShot = now;
                
                // SRê³¼ ìƒ·ê±´ì˜ ê²½ìš° ë°œì‚¬ ì§í›„ ë”œë ˆì´ í‘œì‹œ ì‹œì‘
                if (shooter.currentWeapon === 'sr' || shooter.currentWeapon === 'shotgun') {
                    shooter.showFireDelay = true;
                    shooter.fireDelayEndTime = now + weapon.fireRate;
                }
            } else {
                shooter.lastShot = Date.now();
            }
            
            // ì´êµ¬ ìœ„ì¹˜ ê³„ì‚°
            const barrelLength = 25; // ì´êµ¬ê¹Œì§€ì˜ ê±°ë¦¬
            const barrelX = shooter.x + Math.cos(angle) * barrelLength;
            const barrelY = shooter.y + Math.sin(angle) * barrelLength;
            
            if (shooter.currentWeapon === 'shotgun' || shooter.weapon === 'shotgun') {
                const bulletSpeed = weapon.bulletSpeed || 18;
                const pelletCount = weapon.pellets || 8; // 8ë°œ í ë¦¿
                for (let i = 0; i < pelletCount; i++) {
                    bullets.push({
                        x: barrelX,
                        y: barrelY,
                        vx: Math.cos(angle + (Math.random() - 0.5) * 0.5) * bulletSpeed, // ë” ë„“ì€ ê°ë„ (0.3 â†’ 0.5)
                        vy: Math.sin(angle + (Math.random() - 0.5) * 0.5) * bulletSpeed,
                        damage: weapon.damage, // í ë¦¿ë‹¹ 13 ë°ë¯¸ì§€
                        range: weapon.range,
                        owner: shooter,
                        traveled: 0
                    });
                }
            } else {
                const bulletSpeed = weapon.bulletSpeed || 15;
                bullets.push({
                    x: barrelX,
                    y: barrelY,
                    vx: Math.cos(angle) * bulletSpeed,
                    vy: Math.sin(angle) * bulletSpeed,
                    damage: weapon.damage,
                    range: weapon.range,
                    owner: shooter,
                    traveled: 0
                });
            }
        }
        
        // ìˆ˜ë¥˜íƒ„ íˆ¬ì²™
        function throwGrenade(thrower, targetX, targetY) {
            if (!thrower.grenades || thrower.grenades <= 0) return;
            
            thrower.grenades--;
            
            const angle = Math.atan2(targetY - thrower.y, targetX - thrower.x);
            const dist = Math.min(200, Math.sqrt((targetX - thrower.x) ** 2 + (targetY - thrower.y) ** 2));
            
            grenades.push({
                x: thrower.x,
                y: thrower.y,
                vx: Math.cos(angle) * dist / 30,
                vy: Math.sin(angle) * dist / 30,
                timer: 5000,
                size: 5
            });
        }
        
        // ë°ë¯¸ì§€ ì²˜ë¦¬
        function takeDamage(target, damage, isZoneDamage = false) {
            let finalDamage = damage;
            
            // ìê¸°ì¥ ë°ë¯¸ì§€ê°€ ì•„ë‹ ë•Œë§Œ ë°©ì–´êµ¬ íš¨ê³¼ ì ìš©
            if (!isZoneDamage && target.armor > 0 && target.armorLevel > 0) {
                // ë°©ì–´êµ¬ ë ˆë²¨ì— ë”°ë¥¸ ë°ë¯¸ì§€ ê°ì†Œìœ¨
                const damageReduction = {
                    1: 0.2,  // 1ë ˆë²¨: 20% ê°ì†Œ
                    2: 0.35, // 2ë ˆë²¨: 35% ê°ì†Œ
                    3: 0.5   // 3ë ˆë²¨: 50% ê°ì†Œ
                };
                
                const reduction = damageReduction[target.armorLevel] || 0;
                const reducedDamage = damage * (1 - reduction);
                const armorDamage = damage - reducedDamage;
                
                // ë°©ì–´êµ¬ ë‚´êµ¬ë„ ê°ì†Œ
                target.armor -= armorDamage;
                if (target.armor <= 0) {
                    target.armor = 0;
                    target.armorLevel = 0;
                }
                
                finalDamage = reducedDamage;
            }
            
            target.health -= finalDamage;
            
            // ì²´ë ¥ì´ 0 ì´í•˜ë¡œ ë–¨ì–´ì§€ì§€ ì•Šë„ë¡ ì œí•œ
            if (target.health < 0) {
                target.health = 0;
            }
            
            if (target === player) {
                document.getElementById('damageIndicator').classList.add('damage-flash');
                setTimeout(() => {
                    document.getElementById('damageIndicator').classList.remove('damage-flash');
                }, 500);
            }
            
            createBloodParticles(target.x, target.y);
            
            // ì£½ì—ˆëŠ”ì§€ ì—¬ë¶€ ë°˜í™˜
            return target.health <= 0;
        }
        
        // íŒŒí‹°í´ ìƒì„±
        function createBloodParticles(x, y) {
            for (let i = 0; i < 8; i++) {
                particles.push({
                    x: x,
                    y: y,
                    vx: (Math.random() - 0.5) * 6,
                    vy: (Math.random() - 0.5) * 6,
                    life: 40,
                    color: '#ff0000',
                    size: 2 + Math.random() * 3
                });
            }
        }
        
        // AI ì—…ë°ì´íŠ¸
        function updateAI(enemy) {
            const now = Date.now();
            
            // ìê¸°ì¥ ì²´í¬ - ìµœìš°ì„  ìˆœìœ„
            const distToZoneCenter = Math.sqrt((enemy.x - zone.centerX) ** 2 + (enemy.y - zone.centerY) ** 2);
            const isOutsideZone = zone.isActive && distToZoneCenter > zone.currentRadius;
            const isNearZoneEdge = zone.isActive && distToZoneCenter > zone.currentRadius - 100;
            
            // ìê¸°ì¥ ë°–ì— ìˆê±°ë‚˜ ê°€ì¥ìë¦¬ì— ìˆìœ¼ë©´ ìµœìš°ì„ ìœ¼ë¡œ ì•ˆì „ì§€ëŒ€ë¡œ ì´ë™
            if (isOutsideZone || (isNearZoneEdge && zone.isShrinking)) {
                enemy.ai.state = 'moveToZone';
                enemy.ai.zoneTarget = {
                    x: zone.centerX + (enemy.x - zone.centerX) * (zone.currentRadius - 50) / distToZoneCenter,
                    y: zone.centerY + (enemy.y - zone.centerY) * (zone.currentRadius - 50) / distToZoneCenter
                };
            }
            
            // íí…œ ì‚¬ìš© (ì²´ë ¥ì´ ë‚®ì„ ë•Œ)
            if (enemy.health < 50 && enemy.healthItems > 0 && !enemy.isUsingHealthItem) {
                enemy.isUsingHealthItem = true;
                enemy.healthItemStartTime = now;
                enemy.healthItems--;
            }
            
            // íí…œ ì‚¬ìš© ì™„ë£Œ ì²˜ë¦¬
            if (enemy.isUsingHealthItem && now - enemy.healthItemStartTime >= 3000) {
                enemy.health = Math.min(100, enemy.health + 50);
                enemy.isUsingHealthItem = false;
            }
            
            // ì²´ë ¥ì´ ë§¤ìš° ë‚®ì„ ë•Œë§Œ ë„ë§ (ìê¸°ì¥ ì´ë™ì´ ì•„ë‹ ë•Œ)
            if (enemy.health < 30 && enemy.ai.state !== 'moveToZone') {
                enemy.ai.state = 'flee';
                enemy.ai.fleeTimer = now + 5000;
            }
            
            if (enemy.ai.state === 'flee' && enemy.health > 50 && now > enemy.ai.fleeTimer) {
                enemy.ai.state = 'patrol';
            }
            
            // ì•„ì´í…œ íŒŒë° (ìê¸°ì¥ ì•ˆì „í•  ë•Œë§Œ)
            if ((enemy.ai.state === 'patrol' || enemy.ai.state === 'search') && 
                !isOutsideZone && !isNearZoneEdge &&
                (!enemy.weapon || enemy.armorLevel < 2 || enemy.grenades < 2)) {
                let nearestItem = null;
                let nearestDist = 250;
                
                items.forEach(item => {
                    // ë°©ì–´êµ¬ ìš°ì„ ìˆœìœ„ ê°œì„ 
                    const needsArmor = (item.type.startsWith('armor') && 
                        (enemy.armorLevel < item.data.level || 
                         (enemy.armorLevel === item.data.level && enemy.armor < item.data.maxArmor * 0.7)));
                    
                    if ((item.type === 'weapon' && !enemy.weapon) || 
                        needsArmor || 
                        (item.type === 'medkit' && enemy.health < 80) ||
                        (item.type === 'grenade' && enemy.grenades < 2) ||
                        (item.type.startsWith('ammo_') && enemy.weapon && weapons[enemy.weapon] && 
                         weapons[enemy.weapon].ammo < weapons[enemy.weapon].maxAmmo / 2)) {
                        const dist = distance(enemy, item);
                        if (dist < nearestDist) {
                            nearestItem = item;
                            nearestDist = dist;
                        }
                    }
                });
                
                if (nearestItem) {
                    enemy.ai.farmingTarget = nearestItem;
                    enemy.ai.state = 'farming';
                }
            }
            
            // í”Œë ˆì´ì–´ ê°ì§€ (ìê¸°ì¥ ì•ˆì „í•  ë•Œë§Œ ì ê·¹ì  ì „íˆ¬, ì§‘ ì•ˆ/ë°– ì‹œì•¼ ì œí•œ ì ìš©)
            const distToPlayer = distance(enemy, player);
            
            // AIì™€ í”Œë ˆì´ì–´ê°€ ê°™ì€ ê³µê°„(ì§‘ ì•ˆ ë˜ëŠ” ì§‘ ë°–)ì— ìˆëŠ”ì§€ í™•ì¸
            let canSeePlayer = false;
            
            // AIê°€ ì–´ëŠ ì§‘ì— ìˆëŠ”ì§€ í™•ì¸
            let enemyHouse = null;
            for (let house of houses) {
                if (enemy.x >= house.x && enemy.x <= house.x + house.width &&
                    enemy.y >= house.y && enemy.y <= house.y + house.height) {
                    enemyHouse = house;
                    break;
                }
            }
            
            // í”Œë ˆì´ì–´ê°€ ì–´ëŠ ì§‘ì— ìˆëŠ”ì§€ í™•ì¸
            const playerHouse = isPlayerInHouse();
            
            if (enemyHouse && playerHouse) {
                // ë‘˜ ë‹¤ ì§‘ ì•ˆì— ìˆì„ ë•Œ: ê°™ì€ ì§‘ì— ìˆì–´ì•¼ ì„œë¡œ ë³¼ ìˆ˜ ìˆìŒ
                canSeePlayer = (enemyHouse === playerHouse);
            } else if (!enemyHouse && !playerHouse) {
                // ë‘˜ ë‹¤ ì§‘ ë°–ì— ìˆì„ ë•Œ: ì„œë¡œ ë³¼ ìˆ˜ ìˆìŒ
                canSeePlayer = true;
            } else {
                // í•œ ëª…ì€ ì§‘ ì•ˆ, í•œ ëª…ì€ ì§‘ ë°–: ì„œë¡œ ë³¼ ìˆ˜ ì—†ìŒ
                canSeePlayer = false;
            }
            
            if (distToPlayer < 200 && player.health > 0 && enemy.ai.state !== 'flee' && 
                enemy.ai.state !== 'moveToZone' && canSeePlayer) {
                enemy.ai.state = 'combat';
                enemy.target = player;
                enemy.ai.lastPlayerSeen = now;
            }
            
            if (enemy.ai.state === 'combat' && enemy.target === player && 
                (distToPlayer > 300 || isOutsideZone || isNearZoneEdge || !canSeePlayer)) {
                if (now - enemy.ai.lastPlayerSeen > 3000 || isOutsideZone || isNearZoneEdge || !canSeePlayer) {
                    enemy.ai.state = isOutsideZone || isNearZoneEdge ? 'moveToZone' : 'search';
                    enemy.ai.searchTimer = now + 10000;
                    enemy.target = null;
                }
            }
            
            // ë‹¤ë¥¸ ì  ê°ì§€ (ìê¸°ì¥ ì•ˆì „í•  ë•Œë§Œ, ì§‘ ì•ˆ/ë°– ì‹œì•¼ ì œí•œ ì ìš©)
            if (enemy.ai.state !== 'flee' && enemy.ai.state !== 'moveToZone' && enemy.weapon) {
                enemies.forEach(other => {
                    if (other !== enemy && distance(enemy, other) < 150) {
                        // ë‘ AIê°€ ê°™ì€ ê³µê°„(ì§‘ ì•ˆ ë˜ëŠ” ì§‘ ë°–)ì— ìˆëŠ”ì§€ í™•ì¸
                        let canSeeOther = false;
                        
                        // í˜„ì¬ AIê°€ ì–´ëŠ ì§‘ì— ìˆëŠ”ì§€ í™•ì¸
                        let currentEnemyHouse = null;
                        for (let house of houses) {
                            if (enemy.x >= house.x && enemy.x <= house.x + house.width &&
                                enemy.y >= house.y && enemy.y <= house.y + house.height) {
                                currentEnemyHouse = house;
                                break;
                            }
                        }
                        
                        // ë‹¤ë¥¸ AIê°€ ì–´ëŠ ì§‘ì— ìˆëŠ”ì§€ í™•ì¸
                        let otherEnemyHouse = null;
                        for (let house of houses) {
                            if (other.x >= house.x && other.x <= house.x + house.width &&
                                other.y >= house.y && other.y <= house.y + house.height) {
                                otherEnemyHouse = house;
                                break;
                            }
                        }
                        
                        if (currentEnemyHouse && otherEnemyHouse) {
                            // ë‘˜ ë‹¤ ì§‘ ì•ˆì— ìˆì„ ë•Œ: ê°™ì€ ì§‘ì— ìˆì–´ì•¼ ì„œë¡œ ë³¼ ìˆ˜ ìˆìŒ
                            canSeeOther = (currentEnemyHouse === otherEnemyHouse);
                        } else if (!currentEnemyHouse && !otherEnemyHouse) {
                            // ë‘˜ ë‹¤ ì§‘ ë°–ì— ìˆì„ ë•Œ: ì„œë¡œ ë³¼ ìˆ˜ ìˆìŒ
                            canSeeOther = true;
                        } else {
                            // í•œ ëª…ì€ ì§‘ ì•ˆ, í•œ ëª…ì€ ì§‘ ë°–: ì„œë¡œ ë³¼ ìˆ˜ ì—†ìŒ
                            canSeeOther = false;
                        }
                        
                        if (canSeeOther && Math.random() < 0.01 * enemy.ai.aggressionLevel) {
                            enemy.ai.state = 'combat';
                            enemy.target = other;
                        }
                    }
                });
            }
            
            // AI ìƒíƒœë³„ í–‰ë™
            switch (enemy.ai.state) {
                case 'moveToZone':
                    // ìê¸°ì¥ìœ¼ë¡œ ì´ë™ - ìµœìš°ì„  ìˆœìœ„
                    if (!enemy.ai.zoneTarget) {
                        enemy.ai.state = 'patrol';
                        break;
                    }
                    
                    const distToZoneTarget = distance(enemy, enemy.ai.zoneTarget);
                    if (distToZoneTarget < 30 || !zone.isActive || 
                        (zone.isActive && Math.sqrt((enemy.x - zone.centerX) ** 2 + (enemy.y - zone.centerY) ** 2) < zone.currentRadius - 50)) {
                        enemy.ai.state = 'patrol';
                        enemy.ai.zoneTarget = null;
                        break;
                    }
                    
                    const zoneAngle = angleTo(enemy, enemy.ai.zoneTarget);
                    enemy.angle = zoneAngle;
                    const zoneSpeed = enemy.speed * 1.8; // ìê¸°ì¥ìœ¼ë¡œ ì´ë™í•  ë•ŒëŠ” ë¹ ë¥´ê²Œ
                    const zoneX = enemy.x + Math.cos(zoneAngle) * zoneSpeed;
                    const zoneY = enemy.y + Math.sin(zoneAngle) * zoneSpeed;
                    
                    if (canMoveTo(zoneX, zoneY, enemy.size)) {
                        enemy.x = zoneX;
                        enemy.y = zoneY;
                    } else {
                        // ì¥ì• ë¬¼ì´ ìˆìœ¼ë©´ ìš°íšŒ ê²½ë¡œ ì°¾ê¸°
                        const altAngle1 = zoneAngle + Math.PI / 4;
                        const altAngle2 = zoneAngle - Math.PI / 4;
                        const altX1 = enemy.x + Math.cos(altAngle1) * zoneSpeed;
                        const altY1 = enemy.y + Math.sin(altAngle1) * zoneSpeed;
                        const altX2 = enemy.x + Math.cos(altAngle2) * zoneSpeed;
                        const altY2 = enemy.y + Math.sin(altAngle2) * zoneSpeed;
                        
                        if (canMoveTo(altX1, altY1, enemy.size)) {
                            enemy.x = altX1;
                            enemy.y = altY1;
                        } else if (canMoveTo(altX2, altY2, enemy.size)) {
                            enemy.x = altX2;
                            enemy.y = altY2;
                        }
                    }
                    break;
                    
                case 'patrol':
                    const distToPatrol = distance(enemy, enemy.ai.patrolTarget);
                    if (distToPatrol < 30 || now - enemy.ai.lastStateChange > 5000) {
                        enemy.ai.patrolTarget = {
                            x: Math.random() * MAP_SIZE,
                            y: Math.random() * MAP_SIZE
                        };
                        enemy.ai.lastStateChange = now;
                    }
                    
                    const patrolAngle = angleTo(enemy, enemy.ai.patrolTarget);
                    enemy.angle = patrolAngle; // ì´ë™ ë°©í–¥ìœ¼ë¡œ ê°ë„ ì„¤ì •
                    const patrolSpeed = enemy.speed * (0.6 + Math.random() * 0.4);
                    const newX = enemy.x + Math.cos(patrolAngle) * patrolSpeed;
                    const newY = enemy.y + Math.sin(patrolAngle) * patrolSpeed;
                    
                    if (canMoveTo(newX, newY, enemy.size)) {
                        enemy.x = newX;
                        enemy.y = newY;
                    }
                    break;
                    
                case 'farming':
                    if (!enemy.ai.farmingTarget) {
                        enemy.ai.state = 'patrol';
                        break;
                    }
                    
                    const distToItem = distance(enemy, enemy.ai.farmingTarget);
                    if (distToItem < 20) {
                        const item = enemy.ai.farmingTarget;
                        if (item.type === 'weapon') {
                            // ë” ì¢‹ì€ ë¬´ê¸°ë¡œ êµì²´í•˜ëŠ” ë¡œì§
                            const currentWeaponDamage = enemy.weapon ? weapons[enemy.weapon].damage : 0;
                            const newWeaponDamage = weapons[item.data.weaponType].damage;
                            
                            if (newWeaponDamage > currentWeaponDamage) {
                                // ê¸°ì¡´ ë¬´ê¸°ë¥¼ ë“œë¡­
                                if (enemy.weapon) {
                                    items.push({
                                        x: enemy.x + (Math.random() - 0.5) * 30,
                                        y: enemy.y + (Math.random() - 0.5) * 30,
                                        type: 'weapon',
                                        data: { weaponType: enemy.weapon }
                                    });
                                }
                                enemy.weapon = item.data.weaponType;
                            }
                        } else if (item.type.startsWith('armor')) {
                            // ë°©ì–´êµ¬ ì°©ìš© ë¡œì§ ê°œì„ 
                            const newArmorLevel = item.data.level;
                            const newArmorAmount = item.data.currentArmor || item.data.maxArmor;
                            
                            // ë” ì¢‹ì€ ë°©ì–´êµ¬ì´ê±°ë‚˜ ê°™ì€ ë ˆë²¨ì´ì§€ë§Œ ë‚´êµ¬ë„ê°€ ë” ì¢‹ì„ ë•Œë§Œ êµì²´
                            if (newArmorLevel > enemy.armorLevel || 
                                (newArmorLevel === enemy.armorLevel && newArmorAmount > enemy.armor)) {
                                
                                // ê¸°ì¡´ ë°©ì–´êµ¬ê°€ ìˆìœ¼ë©´ ë“œë¡­
                                if (enemy.armorLevel > 0 && enemy.armor > 0) {
                                    const armorType = enemy.armorLevel === 1 ? 'armor1' : 
                                                    enemy.armorLevel === 2 ? 'armor2' : 'armor3';
                                    const maxArmor = enemy.armorLevel === 1 ? 30 : 
                                                   enemy.armorLevel === 2 ? 60 : 100;
                                    
                                    items.push({
                                        x: enemy.x + (Math.random() - 0.5) * 30,
                                        y: enemy.y + (Math.random() - 0.5) * 30,
                                        type: armorType,
                                        data: { 
                                            level: enemy.armorLevel, 
                                            maxArmor: maxArmor,
                                            currentArmor: enemy.armor 
                                        },
                                        ...itemTypes[armorType]
                                    });
                                }
                                
                                enemy.armor = newArmorAmount;
                                enemy.armorLevel = newArmorLevel;
                            }
                        } else if (item.type === 'medkit') {
                            // ì¦‰ì‹œ ì‚¬ìš©í•˜ì§€ ì•Šê³  ì¸ë²¤í† ë¦¬ì— ì €ì¥
                            enemy.healthItems = Math.min(5, enemy.healthItems + item.data.amount);
                        } else if (item.type === 'grenade') {
                            enemy.grenades = Math.min(5, enemy.grenades + item.data.amount);
                        } else if (item.type.startsWith('ammo_') && enemy.weapon) {
                            // AIë„ íƒ„ì•½ì„ ì¸ë²¤í† ë¦¬ì— ì €ì¥
                            const ammoType = item.data.ammoType;
                            enemy.ammoInventory[ammoType] = (enemy.ammoInventory[ammoType] || 0) + item.data.amount;
                        }
                        
                        const itemIndex = items.indexOf(item);
                        if (itemIndex > -1) {
                            items.splice(itemIndex, 1);
                        }
                        
                        enemy.ai.farmingTarget = null;
                        enemy.ai.state = 'patrol';
                    } else {
                        const farmAngle = angleTo(enemy, enemy.ai.farmingTarget);
                        enemy.angle = farmAngle; // ì•„ì´í…œ ë°©í–¥ìœ¼ë¡œ ê°ë„ ì„¤ì •
                        const farmSpeed = enemy.speed * 1.2; // 1.5ì—ì„œ 1.2ë¡œ ê°ì†Œ
                        const farmX = enemy.x + Math.cos(farmAngle) * farmSpeed;
                        const farmY = enemy.y + Math.sin(farmAngle) * farmSpeed;
                        
                        if (canMoveTo(farmX, farmY, enemy.size)) {
                            enemy.x = farmX;
                            enemy.y = farmY;
                        }
                    }
                    break;
                    
                case 'combat':
                    if (!enemy.target || enemy.target.health <= 0) {
                        enemy.ai.state = 'patrol';
                        enemy.target = null;
                        break;
                    }
                    
                    const distToTarget = distance(enemy, enemy.target);
                    if (distToTarget > 350) {
                        if (enemy.target === player) {
                            enemy.ai.state = 'search';
                            enemy.ai.searchTimer = now + 8000;
                        } else {
                            enemy.ai.state = 'patrol';
                        }
                        enemy.target = null;
                        break;
                    }
                    
                    // íƒ€ê²Ÿì„ í–¥í•´ ê°ë„ ì—…ë°ì´íŠ¸
                    enemy.angle = angleTo(enemy, enemy.target);
                    
                    // ì „íˆ¬ ì¤‘ ì›€ì§ì„ (ìƒí™©ì— ë”°ë¼ ë‹¬ë¦¬ê¸° ì‚¬ìš©)
                    const combatAngle = angleTo(enemy, enemy.target);
                    let moveAngle = combatAngle;
                    let shouldRun = false;
                    
                    // ë‹¬ë¦¬ê¸° ì¡°ê±´: ì²´ë ¥ì´ ë‚®ê±°ë‚˜, ê±°ë¦¬ê°€ ë©€ê±°ë‚˜, ë„ë§ì¹  ë•Œ
                    if (enemy.health < 50 || distToTarget > 150 || enemy.ai.state === 'flee') {
                        shouldRun = true;
                    }
                    
                    if (Math.random() < 0.3) {
                        moveAngle += (Math.random() - 0.5) * Math.PI;
                    } else if (distToTarget < 80 && Math.random() < 0.2) {
                        moveAngle += Math.PI;
                        shouldRun = true; // ë„ˆë¬´ ê°€ê¹Œìš°ë©´ ë‹¬ë ¤ì„œ ë„ë§
                    }
                    
                    const baseSpeed = shouldRun ? enemy.speed * 1.3 : enemy.speed; // 1.8ì—ì„œ 1.3ìœ¼ë¡œ ê°ì†Œ
                    const combatSpeed = baseSpeed * (distToTarget > 120 ? 1.1 : 0.7); // 1.3ì—ì„œ 1.1ë¡œ, 0.8ì—ì„œ 0.7ë¡œ ê°ì†Œ
                    const combatX = enemy.x + Math.cos(moveAngle) * combatSpeed;
                    const combatY = enemy.y + Math.sin(moveAngle) * combatSpeed;
                    
                    if (canMoveTo(combatX, combatY, enemy.size)) {
                        enemy.x = combatX;
                        enemy.y = combatY;
                    }
                    
                    // ì‚¬ê²© (ì •ë°€ì¡°ì¤€ í¬í•¨)
                    if (distToTarget < 250) {
                        if (enemy.weapon && Math.random() < 0.04 * enemy.ai.aggressionLevel) {
                            shoot(enemy, enemy.target.x, enemy.target.y);
                        } else if (!enemy.weapon && distToTarget < 50 && Math.random() < 0.02 * enemy.ai.aggressionLevel) {
                            // ì£¼ë¨¹ ê³µê²©ë„ shoot í•¨ìˆ˜ë¥¼ í†µí•´ ì²˜ë¦¬í•˜ì—¬ ì• ë‹ˆë©”ì´ì…˜ ì‹¤í–‰ (ë” ê°€ê¹Œìš´ ê±°ë¦¬ì—ì„œë§Œ)
                            shoot(enemy, enemy.target.x, enemy.target.y);
                        }
                        
                        if (enemy.grenades > 0 && distToTarget > 80 && distToTarget < 200 && 
                            Date.now() - enemy.ai.lastGrenadeThrow > 8000 && Math.random() < 0.02) {
                            throwGrenade(enemy, enemy.target.x, enemy.target.y);
                            enemy.ai.lastGrenadeThrow = Date.now();
                        }
                    }
                    break;
                    
                case 'flee':
                    let fleeX = 0, fleeY = 0;
                    let threatCount = 0;
                    
                    if (distance(enemy, player) < 250) {
                        const angle = angleTo(player, enemy);
                        fleeX += Math.cos(angle);
                        fleeY += Math.sin(angle);
                        threatCount++;
                    }
                    
                    enemies.forEach(other => {
                        if (other !== enemy && distance(enemy, other) < 180) {
                            const angle = angleTo(other, enemy);
                            fleeX += Math.cos(angle);
                            fleeY += Math.sin(angle);
                            threatCount++;
                        }
                    });
                    
                    if (threatCount > 0) {
                        fleeX /= threatCount;
                        fleeY /= threatCount;
                        
                        // ë„ë§ ë°©í–¥ìœ¼ë¡œ ê°ë„ ì„¤ì •
                        enemy.angle = Math.atan2(fleeY, fleeX);
                        
                        const fleeSpeed = enemy.speed * 1.5; // 2ì—ì„œ 1.5ë¡œ ê°ì†Œ
                        const newFleeX = enemy.x + fleeX * fleeSpeed;
                        const newFleeY = enemy.y + fleeY * fleeSpeed;
                        
                        if (canMoveTo(newFleeX, newFleeY, enemy.size)) {
                            enemy.x = newFleeX;
                            enemy.y = newFleeY;
                        }
                    }
                    break;
                    
                case 'search':
                    if (now > enemy.ai.searchTimer) {
                        enemy.ai.state = 'patrol';
                        return;
                    }
                    
                    if (now - enemy.ai.moveTimer > 1000) {
                        enemy.ai.patrolTarget = {
                            x: player.x + (Math.random() - 0.5) * 200,
                            y: player.y + (Math.random() - 0.5) * 200
                        };
                        enemy.ai.moveTimer = now;
                    }
                    
                    const searchAngle = angleTo(enemy, enemy.ai.patrolTarget);
                    enemy.angle = searchAngle; // ìˆ˜ìƒ‰ ë°©í–¥ìœ¼ë¡œ ê°ë„ ì„¤ì •
                    const searchSpeed = enemy.speed * 1.0; // 1.2ì—ì„œ 1.0ìœ¼ë¡œ ê°ì†Œ
                    const searchX = enemy.x + Math.cos(searchAngle) * searchSpeed;
                    const searchY = enemy.y + Math.sin(searchAngle) * searchSpeed;
                    
                    if (canMoveTo(searchX, searchY, enemy.size)) {
                        enemy.x = searchX;
                        enemy.y = searchY;
                    }
                    break;
            }
        }
    </script>
    <script>
        // ì—…ë°ì´íŠ¸ í•¨ìˆ˜
        function update() {
            if (gameState !== 'playing') return;
            
            // ì—°ì‚¬ ì²˜ë¦¬ (ìŠ¤í˜ì´ìŠ¤ë°” ì œê±°) - êµ¬ë¥´ê¸° ì¤‘ì´ë‚˜ ì¬ì¥ì „ ì¤‘ì—ëŠ” ê³µê²© ë¶ˆê°€
            if (mousePressed && !player.isDashing && !player.isReloading) {
                if (player.currentWeapon === 'grenade') {
                    const worldMouseX = mouseX + camera.x;
                    const worldMouseY = mouseY + camera.y;
                    shoot(player, worldMouseX, worldMouseY);
                } else {
                    const currentWeapon = player.weapons[player.currentWeapon];
                    if (currentWeapon && currentWeapon.autoFire) {
                        const worldMouseX = mouseX + camera.x;
                        const worldMouseY = mouseY + camera.y;
                        shoot(player, worldMouseX, worldMouseY);
                    }
                }
            }
            
            // í”Œë ˆì´ì–´ ì´ë™ (êµ¬ë¥´ê¸° ì¤‘ì´ ì•„ë‹ ë•Œë§Œ)
            if (!player.isDashing) {
                let moveX = 0, moveY = 0;
                if (keys['w']) moveY -= 1;
                if (keys['s']) moveY += 1;
                if (keys['a']) moveX -= 1;
                if (keys['d']) moveX += 1;
                
                player.isRunning = keys['shift'];
                
                if (moveX !== 0 || moveY !== 0) {
                    const length = Math.sqrt(moveX * moveX + moveY * moveY);
                    moveX /= length;
                    moveY /= length;
                    
                    let speed = player.speed;
                    if (player.isRunning) {
                        speed *= 1.8;
                    }
                    
                    const newX = player.x + moveX * speed;
                    const newY = player.y + moveY * speed;
                    
                    if (canMoveTo(newX, player.y, player.size)) {
                        player.x = newX;
                    }
                    if (canMoveTo(player.x, newY, player.size)) {
                        player.y = newY;
                    }
                }
            }
            
            // êµ¬ë¥´ê¸° ì—…ë°ì´íŠ¸
            updateDash();
            
            // ì¬ì¥ì „ ì—…ë°ì´íŠ¸
            updateReload();
            
            // ë°œì‚¬ ë”œë ˆì´ í‘œì‹œ ì—…ë°ì´íŠ¸
            updateFireDelayIndicator();
            
            // ì¹´ë©”ë¼ ì—…ë°ì´íŠ¸ (ì •ë°€ì¡°ì¤€ ì œê±°)
            camera.x = player.x - canvas.width / (2 * zoom);
            camera.y = player.y - canvas.height / (2 * zoom);
            
            // ì¤Œ ì—…ë°ì´íŠ¸ (ìµœì†Œ ì¤Œ ë ˆë²¨ ì œí•œ)
            const MIN_ZOOM = 0.8; // ìµœì†Œ ì¤Œ ë ˆë²¨ (80% ì¶•ì†Œê¹Œì§€ë§Œ í—ˆìš©)
            const MAX_ZOOM = 3.0; // ìµœëŒ€ ì¤Œ ë ˆë²¨
            
            zoom = 1; // ê³ ì • ì¤Œ
            
            // ì¤Œ ë ˆë²¨ ì œí•œ ì ìš©
            zoom = Math.max(MIN_ZOOM, Math.min(MAX_ZOOM, zoom));
            
            // ì´ì•Œ ì—…ë°ì´íŠ¸
            bullets.forEach((bullet, index) => {
                bullet.x += bullet.vx;
                bullet.y += bullet.vy;
                bullet.traveled += Math.sqrt(bullet.vx * bullet.vx + bullet.vy * bullet.vy);
                
                if (bullet.traveled > bullet.range) {
                    bullets.splice(index, 1);
                    return;
                }
                
                // ì¥ì• ë¬¼ ì¶©ëŒ
                for (let obstacle of obstacles) {
                    if (bullet.x > obstacle.x && bullet.x < obstacle.x + obstacle.width &&
                        bullet.y > obstacle.y && bullet.y < obstacle.y + obstacle.height) {
                        bullets.splice(index, 1);
                        return;
                    }
                }
                
                // í”Œë ˆì´ì–´ ì¶©ëŒ
                if (bullet.owner !== player && distance(bullet, player) < player.size) {
                    takeDamage(player, bullet.damage);
                    bullets.splice(index, 1);
                    return;
                }
                
                // ì  ì¶©ëŒ
                for (let enemyIndex = enemies.length - 1; enemyIndex >= 0; enemyIndex--) {
                    const enemy = enemies[enemyIndex];
                    if (bullet.owner !== enemy && distance(bullet, enemy) < enemy.size) {
                        const isDead = takeDamage(enemy, bullet.damage);
                        bullets.splice(index, 1);
                        
                        if (isDead) {
                            if (bullet.owner === player) {
                                player.kills++;
                            }
                            
                            // ì•„ì´í…œ ë“œë¡­
                            if (enemy.weapon) {
                                // ë¬´ê¸° ë“œë¡­
                                items.push({
                                    x: enemy.x + (Math.random() - 0.5) * 30,
                                    y: enemy.y + (Math.random() - 0.5) * 30,
                                    type: 'weapon',
                                    data: { weaponType: enemy.weapon },
                                    ...itemTypes.weapon
                                });
                                
                                // ë¬´ê¸°ì— ë‚¨ì€ íƒ„ì•½ ë“œë¡­
                                const weaponData = weapons[enemy.weapon];
                                if (weaponData && weaponData.ammo > 0) {
                                    const ammoType = `ammo_${weaponData.ammoType}`;
                                    items.push({
                                        x: enemy.x + (Math.random() - 0.5) * 30,
                                        y: enemy.y + (Math.random() - 0.5) * 30,
                                        type: ammoType,
                                        data: { 
                                            ammoType: weaponData.ammoType,
                                            amount: weaponData.ammo 
                                        },
                                        ...itemTypes[ammoType]
                                    });
                                }
                            }
                            if (enemy.armor > 0) {
                                items.push({
                                    x: enemy.x + (Math.random() - 0.5) * 30,
                                    y: enemy.y + (Math.random() - 0.5) * 30,
                                    type: 'armor',
                                    data: { amount: Math.floor(enemy.armor / 2) }
                                });
                            }
                            if (enemy.grenades > 0) {
                                items.push({
                                    x: enemy.x + (Math.random() - 0.5) * 30,
                                    y: enemy.y + (Math.random() - 0.5) * 30,
                                    type: 'grenade',
                                    data: { amount: enemy.grenades }
                                });
                            }
                            
                            enemies.splice(enemyIndex, 1);
                        }
                        break;
                    }
                }
            });
            
            // ìˆ˜ë¥˜íƒ„ ì—…ë°ì´íŠ¸
            grenades.forEach((grenade, index) => {
                grenade.x += grenade.vx;
                grenade.y += grenade.vy;
                grenade.vx *= 0.98;
                grenade.vy *= 0.98;
                grenade.timer -= 16;
                
                if (grenade.timer <= 1000 && grenade.timer > 0) {
                    if (Math.random() < 0.3) {
                        particles.push({
                            x: grenade.x + (Math.random() - 0.5) * 10,
                            y: grenade.y + (Math.random() - 0.5) * 10,
                            vx: (Math.random() - 0.5) * 2,
                            vy: (Math.random() - 0.5) * 2,
                            life: 20,
                            color: '#ff4400',
                            size: 2
                        });
                    }
                }
                
                if (grenade.timer <= 0) {
                    const explosionRadius = 80;
                    
                    const distToPlayer = distance(grenade, player);
                    if (distToPlayer < explosionRadius) {
                        const damage = 60 * (1 - distToPlayer / explosionRadius);
                        const playerDead = takeDamage(player, damage);
                        if (playerDead) {
                            gameState = 'gameOver';
                        }
                    }
                    
                    for (let enemyIndex = enemies.length - 1; enemyIndex >= 0; enemyIndex--) {
                        const enemy = enemies[enemyIndex];
                        const distToEnemy = distance(grenade, enemy);
                        if (distToEnemy < explosionRadius) {
                            const damage = 60 * (1 - distToEnemy / explosionRadius);
                            const isDead = takeDamage(enemy, damage);
                            
                            if (isDead) {
                                player.kills++;
                                
                                // ì•„ì´í…œ ë“œë¡­
                                if (enemy.weapon) {
                                    // ë¬´ê¸° ë“œë¡­
                                    items.push({
                                        x: enemy.x + (Math.random() - 0.5) * 30,
                                        y: enemy.y + (Math.random() - 0.5) * 30,
                                        type: 'weapon',
                                        data: { weaponType: enemy.weapon },
                                        ...itemTypes.weapon
                                    });
                                    
                                    // ë¬´ê¸°ì— ë‚¨ì€ íƒ„ì•½ ë“œë¡­
                                    const weaponData = weapons[enemy.weapon];
                                    if (weaponData && weaponData.ammo > 0) {
                                        const ammoType = `ammo_${weaponData.ammoType}`;
                                        items.push({
                                            x: enemy.x + (Math.random() - 0.5) * 30,
                                            y: enemy.y + (Math.random() - 0.5) * 30,
                                            type: ammoType,
                                            data: { 
                                                ammoType: weaponData.ammoType,
                                                amount: weaponData.ammo 
                                            },
                                            ...itemTypes[ammoType]
                                        });
                                    }
                                }
                                if (enemy.armor > 0) {
                                    items.push({
                                        x: enemy.x + (Math.random() - 0.5) * 30,
                                        y: enemy.y + (Math.random() - 0.5) * 30,
                                        type: 'armor',
                                        data: { amount: Math.floor(enemy.armor / 2) }
                                    });
                                }
                                if (enemy.grenades > 0) {
                                    items.push({
                                        x: enemy.x + (Math.random() - 0.5) * 30,
                                        y: enemy.y + (Math.random() - 0.5) * 30,
                                        type: 'grenade',
                                        data: { amount: enemy.grenades }
                                    });
                                }
                                
                                enemies.splice(enemyIndex, 1);
                            }
                        }
                    }
                    
                    // í­ë°œ íŒŒí‹°í´
                    for (let i = 0; i < 30; i++) {
                        particles.push({
                            x: grenade.x,
                            y: grenade.y,
                            vx: (Math.random() - 0.5) * 15,
                            vy: (Math.random() - 0.5) * 15,
                            life: 60,
                            color: i < 15 ? '#ff8800' : '#ffaa00',
                            size: 4 + Math.random() * 4
                        });
                    }
                    
                    for (let i = 0; i < 20; i++) {
                        particles.push({
                            x: grenade.x,
                            y: grenade.y,
                            vx: (Math.random() - 0.5) * 8,
                            vy: (Math.random() - 0.5) * 8,
                            life: 100,
                            color: '#666666',
                            size: 6 + Math.random() * 6
                        });
                    }
                    
                    grenades.splice(index, 1);
                }
            });
            
            // AI ì—…ë°ì´íŠ¸
            enemies.forEach(enemy => {
                updateAI(enemy);
            });
            
            // ìê¸°ì¥ ì—…ë°ì´íŠ¸
            updateZone();
            
            // ìê¸°ì¥ íƒ€ì´ë¨¸ ì—…ë°ì´íŠ¸
            updateZoneTimer();
            
            // íŒŒí‹°í´ ì—…ë°ì´íŠ¸
            particles.forEach((particle, index) => {
                particle.x += particle.vx;
                particle.y += particle.vy;
                particle.vx *= 0.95;
                particle.vy *= 0.95;
                particle.life--;
                
                if (particle.life <= 0) {
                    particles.splice(index, 1);
                }
            });
            
            // ê²Œì„ ì¢…ë£Œ ì²´í¬
            if (player.health <= 0) {
                gameState = 'gameOver';
                document.getElementById('gameResult').textContent = 'ì‚¬ë§!';
                document.getElementById('finalRank').textContent = `ìˆœìœ„: ${enemies.length + 1}ìœ„`;
                document.getElementById('finalStats').textContent = `í‚¬: ${player.kills}`;
                document.getElementById('gameOver').style.display = 'block';
            } else if (enemies.length === 0) {
                gameState = 'gameOver';
                document.getElementById('gameResult').textContent = 'ğŸ† ìŠ¹ë¦¬!';
                document.getElementById('finalRank').textContent = 'ìˆœìœ„: 1ìœ„';
                document.getElementById('finalStats').textContent = `í‚¬: ${player.kills}`;
                document.getElementById('gameOver').style.display = 'block';
            }
            
            updateHUD();
        }
        
        // ë Œë”ë§ í•¨ìˆ˜
        function render() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            ctx.save();
            ctx.scale(zoom, zoom);
            ctx.translate(-camera.x, -camera.y);
            
            // ë°°ê²½ ê·¸ë¦¬ê¸°
            drawGrassTexture();
            
            // ì§‘ ê·¸ë¦¬ê¸° (ë²„ë“œì•„ì´ë·°)
            const playerHouse = isPlayerInHouse();
            
            houses.forEach(house => {
                const isPlayerInThisHouse = (playerHouse === house);
                
                // ì§‘ ë°”ë‹¥ (í•­ìƒ ë³´ì„)
                ctx.fillStyle = '#4A4A4A'; // íšŒìƒ‰ ë°”ë‹¥ìœ¼ë¡œ ë³€ê²½
                ctx.fillRect(house.x, house.y, house.width, house.height);
                
                // ë°”ë‹¥ íŒ¨í„´
                ctx.fillStyle = '#5A5A5A';
                for (let i = 0; i < house.width; i += 20) {
                    for (let j = 0; j < house.height; j += 20) {
                        ctx.fillRect(house.x + i, house.y + j, 2, 2);
                    }
                }
                
                // ë²½ (í”Œë ˆì´ì–´ê°€ ì§‘ ì•ˆì— ìˆì„ ë•ŒëŠ” ë°˜íˆ¬ëª…)
                if (isPlayerInThisHouse) {
                    ctx.globalAlpha = 0.3; // ë°˜íˆ¬ëª…
                } else {
                    ctx.globalAlpha = 1.0; // ë¶ˆíˆ¬ëª…
                }
                
                ctx.fillStyle = '#654321';
                ctx.lineWidth = 4;
                
                // ë²½ ê·¸ë¦¬ê¸° (í…Œë‘ë¦¬)
                ctx.fillRect(house.x - 4, house.y - 4, house.width + 8, 4); // ìœ„ìª½ ë²½
                ctx.fillRect(house.x - 4, house.y + house.height, house.width + 8, 4); // ì•„ë˜ìª½ ë²½
                ctx.fillRect(house.x - 4, house.y, 4, house.height); // ì™¼ìª½ ë²½
                ctx.fillRect(house.x + house.width, house.y, 4, house.height); // ì˜¤ë¥¸ìª½ ë²½
                
                // ë¬¸ (ì•„ë˜ìª½ ë²½ì— êµ¬ë©)
                ctx.fillStyle = '#4A4A4A'; // ë°”ë‹¥ìƒ‰ìœ¼ë¡œ ë¬¸ êµ¬ë© ë§Œë“¤ê¸°
                ctx.fillRect(house.doorX, house.doorY, house.doorWidth, 4);
                
                ctx.globalAlpha = 1.0; // íˆ¬ëª…ë„ ë³µì›
                
                // ì§€ë¶• (í”Œë ˆì´ì–´ê°€ ì§‘ ì•ˆì— ìˆì„ ë•ŒëŠ” ìˆ¨ê¹€)
                if (!isPlayerInThisHouse) {
                    ctx.fillStyle = '#8B0000';
                    ctx.fillRect(house.x - 8, house.y - 8, house.width + 16, house.height + 16);
                    
                    // ì§€ë¶• íŒ¨í„´
                    ctx.fillStyle = '#A52A2A';
                    for (let i = 0; i < house.width + 16; i += 15) {
                        for (let j = 0; j < house.height + 16; j += 15) {
                            ctx.fillRect(house.x - 8 + i, house.y - 8 + j, 2, 2);
                        }
                    }
                }
                
                // ì°½ë¬¸ (ë²½ì— ìˆì„ ë•Œë§Œ)
                if (!isPlayerInThisHouse) {
                    ctx.fillStyle = '#87CEEB';
                    ctx.fillRect(house.x + 15, house.y - 2, 12, 2); // ìœ„ìª½ ì°½ë¬¸
                    ctx.fillRect(house.x + house.width - 27, house.y - 2, 12, 2); // ìœ„ìª½ ì°½ë¬¸
                }
            });
            
            // ì¥ì• ë¬¼ ê·¸ë¦¬ê¸°
            obstacles.forEach(obstacle => {
                drawObstacle(obstacle);
            });
            
            // ì•„ì´í…œ ê·¸ë¦¬ê¸° (ì§‘ ì•ˆì— ìˆì„ ë•Œë§Œ ê°™ì€ ì§‘ì˜ ì•„ì´í…œ ë³´ì„)
            items.forEach(item => {
                let shouldDrawItem = true;
                
                // ì•„ì´í…œì´ ì§‘ ì•ˆì— ìˆëŠ”ì§€ í™•ì¸
                let itemInHouse = null;
                for (let house of houses) {
                    if (item.x >= house.x && item.x <= house.x + house.width &&
                        item.y >= house.y && item.y <= house.y + house.height) {
                        itemInHouse = house;
                        break;
                    }
                }
                
                if (itemInHouse) {
                    // ì•„ì´í…œì´ ì§‘ ì•ˆì— ìˆì„ ë•Œ
                    if (playerHouse) {
                        // í”Œë ˆì´ì–´ê°€ ì§‘ ì•ˆì— ìˆì„ ë•ŒëŠ” ê°™ì€ ì§‘ì˜ ì•„ì´í…œë§Œ ë³´ì„
                        shouldDrawItem = (itemInHouse === playerHouse);
                    } else {
                        // í”Œë ˆì´ì–´ê°€ ë°–ì— ìˆì„ ë•ŒëŠ” ì§‘ ì•ˆ ì•„ì´í…œ ì•ˆ ë³´ì„
                        shouldDrawItem = false;
                    }
                } else {
                    // ì•„ì´í…œì´ ë°–ì— ìˆì„ ë•ŒëŠ” í”Œë ˆì´ì–´ê°€ ë°–ì— ìˆì„ ë•Œë§Œ ë³´ì„
                    shouldDrawItem = !playerHouse;
                }
                
                if (shouldDrawItem) {
                    drawItem(item);
                }
            });
            
            // ì ë“¤ ê·¸ë¦¬ê¸° (ì§‘ ì•ˆ/ë°– ì‹œì•¼ ì œí•œ)
            enemies.forEach(enemy => {
                let shouldDraw = true;
                
                // ì ì´ ì–´ëŠ ì§‘ì— ìˆëŠ”ì§€ í™•ì¸
                let enemyHouse = null;
                for (let house of houses) {
                    if (enemy.x >= house.x && enemy.x <= house.x + house.width &&
                        enemy.y >= house.y && enemy.y <= house.y + house.height) {
                        enemyHouse = house;
                        break;
                    }
                }
                
                if (playerHouse) {
                    // í”Œë ˆì´ì–´ê°€ ì§‘ ì•ˆì— ìˆì„ ë•Œ
                    if (enemyHouse) {
                        // ì ë„ ì§‘ ì•ˆì— ìˆì„ ë•Œ: ê°™ì€ ì§‘ì— ìˆì„ ë•Œë§Œ ë³´ì„
                        shouldDraw = (enemyHouse === playerHouse);
                    } else {
                        // ì ì´ ì§‘ ë°–ì— ìˆì„ ë•Œ: ë³´ì´ì§€ ì•ŠìŒ
                        shouldDraw = false;
                    }
                } else {
                    // í”Œë ˆì´ì–´ê°€ ì§‘ ë°–ì— ìˆì„ ë•Œ
                    if (enemyHouse) {
                        // ì ì´ ì§‘ ì•ˆì— ìˆì„ ë•Œ: ë³´ì´ì§€ ì•ŠìŒ
                        shouldDraw = false;
                    } else {
                        // ì ë„ ì§‘ ë°–ì— ìˆì„ ë•Œ: ë³´ì„
                        shouldDraw = true;
                    }
                }
                
                if (shouldDraw) {
                    drawEnemy(enemy);
                }
            });
            
            // í”Œë ˆì´ì–´ ê·¸ë¦¬ê¸°
            drawPlayer();
            
            // ìê¸°ì¥ ê·¸ë¦¬ê¸° (íŒŒë€ìƒ‰)
            if (zone.isActive) {
                // í”Œë ˆì´ì–´ê°€ ìê¸°ì¥ ë°–ì— ìˆì„ ë•Œë§Œ ìœ„í—˜ í‘œì‹œ
                const playerDist = Math.sqrt((player.x - zone.centerX) ** 2 + (player.y - zone.centerY) ** 2);
                const isPlayerOutside = playerDist > zone.currentRadius;
                
                if (isPlayerOutside) {
                    // ìê¸°ì¥ ì™¸ë¶€ ì˜ì—­ì„ ì•½í•œ ë¹¨ê°„ìƒ‰ìœ¼ë¡œ í‘œì‹œ (ìœ„í—˜ ì§€ì—­)
                    ctx.save();
                    ctx.globalCompositeOperation = 'source-over';
                    
                    // ì „ì²´ ë§µì„ ì•½í•œ ë¹¨ê°„ìƒ‰ìœ¼ë¡œ ì¹ í•˜ê¸°
                    ctx.fillStyle = 'rgba(255, 50, 50, 0.15)';
                    ctx.fillRect(0, 0, MAP_SIZE, MAP_SIZE);
                    
                    // ìê¸°ì¥ ë‚´ë¶€ë¥¼ íˆ¬ëª…í•˜ê²Œ ë§Œë“¤ê¸° (êµ¬ë© ëš«ê¸°)
                    ctx.globalCompositeOperation = 'destination-out';
                    ctx.beginPath();
                    ctx.arc(zone.centerX, zone.centerY, zone.currentRadius, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.restore();
                }
                
                // ë‹¤ìŒ ìê¸°ì¥ ë¯¸ë¦¬ë³´ê¸° (ì ì„ )
                if (zone.showNextZone) {
                    ctx.strokeStyle = '#0088ff';
                    ctx.lineWidth = 3;
                    ctx.setLineDash([10, 10]);
                    ctx.beginPath();
                    ctx.arc(zone.nextCenterX, zone.nextCenterY, zone.nextRadius, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.setLineDash([]);
                    
                    // ë‹¤ìŒ ìê¸°ì¥ ì¤‘ì‹¬ì 
                    ctx.fillStyle = '#0088ff';
                    ctx.beginPath();
                    ctx.arc(zone.nextCenterX, zone.nextCenterY, 3, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                // í˜„ì¬ ìê¸°ì¥ ê²½ê³„ì„  (ì‹¤ì„ )
                ctx.strokeStyle = '#0066ff';
                ctx.lineWidth = 6;
                ctx.setLineDash([]);
                ctx.beginPath();
                ctx.arc(zone.centerX, zone.centerY, zone.currentRadius, 0, Math.PI * 2);
                ctx.stroke();
                
                // ìê¸°ì¥ì´ ì¶•ì†Œ ì¤‘ì¼ ë•Œ ì¶•ì†Œ ì¤‘ì¸ ìê¸°ì¥ í‘œì‹œ
                if (zone.isShrinking) {
                    ctx.strokeStyle = '#ff6600';
                    ctx.lineWidth = 4;
                    ctx.setLineDash([5, 5]);
                    ctx.beginPath();
                    ctx.arc(zone.centerX, zone.centerY, zone.targetRadius, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.setLineDash([]);
                }
                
                // ìê¸°ì¥ ì¤‘ì‹¬ì  í‘œì‹œ
                ctx.fillStyle = '#0066ff';
                ctx.beginPath();
                ctx.arc(zone.centerX, zone.centerY, 3, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // ì´ì•Œ ê·¸ë¦¬ê¸°
            bullets.forEach(bullet => {
                ctx.fillStyle = '#ffff00';
                ctx.shadowColor = '#ffff00';
                ctx.shadowBlur = 8;
                ctx.beginPath();
                ctx.arc(bullet.x, bullet.y, 4, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;
                
                ctx.strokeStyle = '#ffff88';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(bullet.x - bullet.vx * 2, bullet.y - bullet.vy * 2);
                ctx.lineTo(bullet.x, bullet.y);
                ctx.stroke();
            });
            
            // ìˆ˜ë¥˜íƒ„ ê·¸ë¦¬ê¸°
            ctx.fillStyle = '#8B0000';
            grenades.forEach(grenade => {
                ctx.beginPath();
                ctx.arc(grenade.x, grenade.y, grenade.size, 0, Math.PI * 2);
                ctx.fill();
            });
            
            // íŒŒí‹°í´ ê·¸ë¦¬ê¸°
            particles.forEach(particle => {
                ctx.fillStyle = particle.color;
                ctx.globalAlpha = particle.life / 40;
                ctx.beginPath();
                ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1;
            });
            
            ctx.restore();
            
            renderMinimap();
        }
        
        // ì”ë”” í…ìŠ¤ì²˜ ê·¸ë¦¬ê¸°
        function drawGrassTexture() {
            ctx.fillStyle = '#90EE90';
            ctx.fillRect(0, 0, MAP_SIZE, MAP_SIZE);
            
            const startX = Math.max(0, Math.floor(camera.x / 100) * 100);
            const endX = Math.min(MAP_SIZE, Math.ceil((camera.x + canvas.width / zoom) / 100) * 100);
            const startY = Math.max(0, Math.floor(camera.y / 100) * 100);
            const endY = Math.min(MAP_SIZE, Math.ceil((camera.y + canvas.height / zoom) / 100) * 100);
            
            ctx.fillStyle = '#7CFC00';
            for (let x = startX; x < endX; x += 20) {
                for (let y = startY; y < endY; y += 20) {
                    const seed = (x * 73 + y * 37) % 1000;
                    if (seed < 300) {
                        ctx.fillRect(x + (seed % 15), y + ((seed * 7) % 15), 2, 2);
                    }
                }
            }
            
            ctx.fillStyle = '#228B22';
            for (let x = startX; x < endX; x += 40) {
                for (let y = startY; y < endY; y += 40) {
                    const seed = (x * 31 + y * 17) % 1000;
                    if (seed < 150) {
                        ctx.fillRect(x + (seed % 20), y + ((seed * 3) % 20), 3, 3);
                    }
                }
            }
        }
    </script>
    <script>
        // ê·¸ë¦¬ê¸° í•¨ìˆ˜ë“¤
        function drawObstacle(obstacle) {
            if (obstacle.type === 'tree') {
                ctx.fillStyle = '#228B22';
                ctx.fillRect(obstacle.x, obstacle.y, obstacle.width, obstacle.height * 0.7);
                
                ctx.fillStyle = '#8B4513';
                const trunkWidth = obstacle.width * 0.3;
                const trunkHeight = obstacle.height * 0.4;
                ctx.fillRect(
                    obstacle.x + (obstacle.width - trunkWidth) / 2, 
                    obstacle.y + obstacle.height * 0.6, 
                    trunkWidth, 
                    trunkHeight
                );
                
                ctx.fillStyle = '#32CD32';
                for (let i = 0; i < 10; i++) {
                    const leafX = obstacle.x + Math.random() * obstacle.width;
                    const leafY = obstacle.y + Math.random() * obstacle.height * 0.7;
                    ctx.fillRect(leafX, leafY, 2, 2);
                }
            } else if (obstacle.type === 'rock') {
                ctx.fillStyle = '#696969';
                ctx.fillRect(obstacle.x, obstacle.y, obstacle.width, obstacle.height);
                
                ctx.fillStyle = '#808080';
                for (let i = 0; i < 8; i++) {
                    const rockX = obstacle.x + Math.random() * obstacle.width;
                    const rockY = obstacle.y + Math.random() * obstacle.height;
                    ctx.fillRect(rockX, rockY, 3, 3);
                }
                
                ctx.fillStyle = '#A9A9A9';
                for (let i = 0; i < 5; i++) {
                    const lightX = obstacle.x + Math.random() * obstacle.width;
                    const lightY = obstacle.y + Math.random() * obstacle.height;
                    ctx.fillRect(lightX, lightY, 2, 2);
                }
            }
        }
        
        function drawItem(item) {
            switch(item.type) {
                case 'weapon':
                    drawWeaponItem(item);
                    break;
                case 'ammo_rifle':
                case 'ammo_shotgun':
                case 'ammo_smg':
                case 'ammo_sniper':
                    drawAmmoItem(item);
                    break;
                case 'armor1':
                case 'armor2':
                case 'armor3':
                    drawArmorItem(item);
                    break;
                case 'medkit':
                    drawMedkitItem(item);
                    break;
                case 'bandage':
                    drawBandageItem(item);
                    break;
                case 'grenade':
                    drawGrenadeItem(item);
                    break;
            }
        }
        
        function drawWeaponItem(item) {
            const weaponType = item.data.weaponType;
            ctx.save();
            ctx.translate(item.x, item.y);
            
            switch(weaponType) {
                case 'ar':
                    ctx.fillStyle = '#000000'; // ê²€ì€ìƒ‰
                    ctx.fillRect(-12, -2, 24, 4);
                    ctx.fillRect(8, -3, 6, 6);
                    break;
                case 'shotgun':
                    ctx.fillStyle = '#8B4513'; // ê°ˆìƒ‰
                    ctx.fillRect(-15, -3, 30, 6);
                    ctx.fillRect(10, -4, 8, 8);
                    break;
                case 'smg':
                    ctx.fillStyle = '#00CED1'; // ì²­ë¡ìƒ‰ (DarkTurquoise)
                    ctx.fillRect(-10, -2, 20, 4);
                    ctx.fillRect(6, -3, 6, 6);
                    break;
                case 'sr':
                    ctx.fillStyle = '#D3D3D3'; // ë°ì€ íšŒìƒ‰
                    ctx.fillRect(-18, -1, 36, 2);
                    ctx.fillRect(12, -4, 8, 8);
                    break;
            }
            
            ctx.restore();
        }
        
        function drawAmmoItem(item) {
            // íƒ„ì•½ íƒ€ì…ë³„ ìƒ‰ìƒ ì ìš©
            let ammoColor = '#FFA500'; // ê¸°ë³¸ ìƒ‰ìƒ
            if (item.type === 'ammo_rifle') ammoColor = '#000000'; // ê²€ì€ìƒ‰
            else if (item.type === 'ammo_shotgun') ammoColor = '#8B4513'; // ê°ˆìƒ‰
            else if (item.type === 'ammo_smg') ammoColor = '#00CED1'; // ì²­ë¡ìƒ‰
            else if (item.type === 'ammo_sniper') ammoColor = '#D3D3D3'; // ë°ì€ íšŒìƒ‰
            
            ctx.fillStyle = ammoColor;
            ctx.fillRect(item.x - 6, item.y - 8, 12, 16);
            
            // ë°ì€ ìƒ‰ìƒìœ¼ë¡œ í•˜ì´ë¼ì´íŠ¸
            ctx.fillStyle = '#FFD700';
            ctx.fillRect(item.x - 4, item.y - 6, 8, 4);
            ctx.fillRect(item.x - 4, item.y + 2, 8, 4);
            
            // íƒ„ì•½ ê°œìˆ˜ í‘œì‹œ
            ctx.fillStyle = '#ffffff';
            ctx.font = '8px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(item.data.amount.toString(), item.x, item.y + 15);
        }
        
        function drawArmorItem(item) {
            // ë°©ì–´êµ¬ ë ˆë²¨ì— ë”°ë¥¸ ìƒ‰ìƒ
            let armorColor = '#808080'; // ê¸°ë³¸ íšŒìƒ‰
            if (item.type === 'armor2') armorColor = '#C0C0C0'; // ë°ì€ íšŒìƒ‰
            else if (item.type === 'armor3') armorColor = '#2F2F2F'; // ê²€ì€ìƒ‰
            
            // ë‚´êµ¬ë„ì— ë”°ë¥¸ íˆ¬ëª…ë„ ì¡°ì •
            const durabilityRatio = (item.data.currentArmor || item.data.maxArmor) / item.data.maxArmor;
            const alpha = 0.5 + (durabilityRatio * 0.5); // 50%~100% íˆ¬ëª…ë„
            
            ctx.globalAlpha = alpha;
            ctx.fillStyle = armorColor;
            ctx.beginPath();
            ctx.arc(item.x, item.y - 3, 8, 0, Math.PI, true);
            ctx.fill();
            ctx.fillRect(item.x - 8, item.y - 3, 16, 10);
            
            // ë ˆë²¨ í‘œì‹œ
            ctx.fillStyle = '#ffffff';
            ctx.font = '10px Arial';
            ctx.textAlign = 'center';
            const level = item.data.level || 1;
            ctx.fillText(level.toString(), item.x, item.y + 2);
            
            // ë‚´êµ¬ë„ í‘œì‹œ (50% ì´í•˜ì¼ ë•Œë§Œ)
            if (durabilityRatio <= 0.5) {
                ctx.fillStyle = '#ff4444';
                ctx.font = '8px Arial';
                const durabilityPercent = Math.floor(durabilityRatio * 100);
                ctx.fillText(`${durabilityPercent}%`, item.x, item.y + 12);
            }
            
            // í…Œë‘ë¦¬
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.arc(item.x, item.y - 3, 8, 0, Math.PI, true);
            ctx.stroke();
            ctx.strokeRect(item.x - 8, item.y - 3, 16, 10);
            
            ctx.globalAlpha = 1.0; // íˆ¬ëª…ë„ ë³µì›
        }
        
        function drawMedkitItem(item) {
            ctx.fillStyle = '#32CD32';
            ctx.fillRect(item.x - 8, item.y - 6, 16, 12);
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(item.x - 1, item.y - 4, 2, 8);
            ctx.fillRect(item.x - 4, item.y - 1, 8, 2);
        }
        
        function drawBandageItem(item) {
            ctx.fillStyle = '#F5F5DC';
            ctx.fillRect(item.x - 6, item.y - 3, 12, 6);
            ctx.fillStyle = '#FF6347';
            ctx.fillRect(item.x - 1, item.y - 2, 2, 4);
        }
        
        function drawGrenadeItem(item) {
            ctx.fillStyle = '#8B0000';
            ctx.beginPath();
            ctx.arc(item.x, item.y, 6, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#A0522D';
            ctx.fillRect(item.x - 2, item.y - 8, 4, 4);
        }
        
        function drawEnemy(enemy) {
            ctx.fillStyle = '#ff4444';
            ctx.beginPath();
            ctx.arc(enemy.x, enemy.y, enemy.size, 0, Math.PI * 2);
            ctx.fill();
            
            // ë¬´ê¸° ê·¸ë¦¬ê¸°
            if (enemy.weapon) {
                const angle = enemy.angle;
                drawWeapon(enemy.x, enemy.y, angle, enemy.weapon, enemy);
            } else {
                // ì£¼ë¨¹ ê·¸ë¦¬ê¸°
                const angle = enemy.angle;
                drawWeapon(enemy.x, enemy.y, angle, 'fist', enemy);
            }
            
            if (enemy.health < 100) {
                ctx.fillStyle = '#000';
                ctx.fillRect(enemy.x - 15, enemy.y - 25, 30, 4);
                ctx.fillStyle = '#ff0000';
                ctx.fillRect(enemy.x - 15, enemy.y - 25, 30 * (enemy.health / 100), 4);
            }
            
            if (enemy.weapon) {
                ctx.fillStyle = '#000';
                ctx.font = '8px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(enemy.weapon.toUpperCase(), enemy.x, enemy.y + 25);
            }
        }
        
        function drawPlayer() {
            ctx.fillStyle = '#4444ff';
            ctx.beginPath();
            ctx.arc(player.x, player.y, player.size, 0, Math.PI * 2);
            ctx.fill();
            
            // ë°©ì–´êµ¬ ë ˆë²¨ì— ë”°ë¥¸ ì‹œê°ì  í‘œì‹œ (ì™¸ê³½ì„ ë§Œ)
            if (player.armorLevel > 0 && player.armor > 0) {
                // ë°©ì–´êµ¬ ë ˆë²¨ë³„ ìƒ‰ìƒ
                const armorColors = {
                    1: '#808080', // íšŒìƒ‰
                    2: '#C0C0C0', // ë°ì€ íšŒìƒ‰
                    3: '#2F2F2F'  // ê²€ì€ìƒ‰
                };
                
                const armorColor = armorColors[player.armorLevel];
                const maxArmor = player.armorLevel === 1 ? 30 : player.armorLevel === 2 ? 60 : 100;
                const durabilityRatio = player.armor / maxArmor;
                
                // ë°©ì–´êµ¬ ì™¸ê³½ì„ ë§Œ í‘œì‹œ
                ctx.strokeStyle = armorColor;
                ctx.lineWidth = 4;
                ctx.globalAlpha = 0.7 + (durabilityRatio * 0.3); // ë‚´êµ¬ë„ì— ë”°ë¥¸ íˆ¬ëª…ë„
                ctx.beginPath();
                ctx.arc(player.x, player.y, player.size + 3, 0, Math.PI * 2);
                ctx.stroke();
                
                ctx.globalAlpha = 1.0;
            }
            
            ctx.fillStyle = '#000';
            ctx.font = '10px Arial';
            ctx.textAlign = 'center';
            const weaponName = player.weapons[player.currentWeapon].name;
            ctx.fillText(weaponName, player.x, player.y + 25);
            
            const worldMouseX = mouseX + camera.x;
            const worldMouseY = mouseY + camera.y;
            const angle = Math.atan2(worldMouseY - player.y, worldMouseX - player.x);
            
            drawWeapon(player.x, player.y, angle, player.currentWeapon, player);
        }
        
        function drawWeapon(x, y, angle, weaponType, entity = null) {
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(angle);
            
            switch(weaponType) {
                case 'fist':
                    drawBoxingFists(entity);
                    break;
                case 'grenade':
                    // ìˆ˜ë¥˜íƒ„ ê·¸ë¦¬ê¸°
                    ctx.fillStyle = '#8B0000';
                    ctx.beginPath();
                    ctx.arc(20, 0, 6, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#A0522D';
                    ctx.fillRect(18, -8, 4, 4);
                    break;
                case 'ar':
                    ctx.fillStyle = '#000000'; // ê²€ì€ìƒ‰
                    ctx.fillRect(15, -2, 25, 4);
                    ctx.fillRect(35, -4, 8, 8);
                    ctx.fillRect(20, -1, 3, 2);
                    break;
                case 'shotgun':
                    ctx.fillStyle = '#8B4513'; // ê°ˆìƒ‰
                    ctx.fillRect(15, -3, 30, 6);
                    ctx.fillRect(40, -5, 10, 10);
                    ctx.fillRect(25, -2, 2, 4);
                    break;
                case 'smg':
                    ctx.fillStyle = '#00CED1'; // ì²­ë¡ìƒ‰ (DarkTurquoise)
                    ctx.fillRect(15, -2, 20, 4);
                    ctx.fillRect(30, -3, 6, 6);
                    ctx.fillRect(18, -1, 2, 2);
                    break;
                case 'sr':
                    ctx.fillStyle = '#D3D3D3'; // ë°ì€ íšŒìƒ‰
                    ctx.fillRect(15, -1, 35, 2);
                    ctx.fillRect(45, -4, 8, 8);
                    ctx.fillRect(25, -3, 15, 6);
                    break;
            }
            
            ctx.restore();
        }
        
        // ë³µì‹± ìì„¸ì˜ ì£¼ë¨¹ì„ ê·¸ë¦¬ëŠ” í•¨ìˆ˜
        function drawBoxingFists(entity) {
            const now = Date.now();
            let leftHandOffset = 0;
            let rightHandOffset = 0;
            
            // í€ì¹˜ ì• ë‹ˆë©”ì´ì…˜ ì²˜ë¦¬
            if (entity && entity.punchAnimation.isActive) {
                const elapsed = now - entity.punchAnimation.startTime;
                const progress = Math.min(elapsed / entity.punchAnimation.duration, 1);
                
                if (progress >= 1) {
                    entity.punchAnimation.isActive = false;
                }
                
                // í€ì¹˜ ì• ë‹ˆë©”ì´ì…˜ ê³¡ì„  (ë¹ ë¥´ê²Œ ë‚˜ê°€ê³  ì²œì²œíˆ ëŒì•„ì˜´)
                const punchDistance = Math.sin(progress * Math.PI) * 12;
                
                if (entity.punchAnimation.currentHand === 'left') {
                    leftHandOffset = punchDistance;
                } else {
                    rightHandOffset = punchDistance;
                }
            }
            
            // ì™¼ì† (ìœ„ìª½)
            ctx.fillStyle = '#FFB6C1';
            ctx.beginPath();
            ctx.arc(18 + leftHandOffset, -8, 4, 0, Math.PI * 2);
            ctx.fill();
            
            // ì™¼íŒ”
            ctx.strokeStyle = '#FFB6C1';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(8, -6);
            ctx.lineTo(14 + leftHandOffset, -8);
            ctx.stroke();
            
            // ì˜¤ë¥¸ì† (ì•„ë˜ìª½)
            ctx.fillStyle = '#FFB6C1';
            ctx.beginPath();
            ctx.arc(18 + rightHandOffset, 8, 4, 0, Math.PI * 2);
            ctx.fill();
            
            // ì˜¤ë¥¸íŒ”
            ctx.strokeStyle = '#FFB6C1';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(8, 6);
            ctx.lineTo(14 + rightHandOffset, 8);
            ctx.stroke();
            
            // ì£¼ë¨¹ ë””í…Œì¼ (ì†ê°€ë½ í‘œí˜„)
            ctx.fillStyle = '#E6A8B8';
            
            // ì™¼ì† ì†ê°€ë½
            ctx.fillRect(16 + leftHandOffset, -10, 2, 4);
            ctx.fillRect(18 + leftHandOffset, -10, 2, 4);
            ctx.fillRect(20 + leftHandOffset, -10, 2, 4);
            
            // ì˜¤ë¥¸ì† ì†ê°€ë½
            ctx.fillRect(16 + rightHandOffset, 6, 2, 4);
            ctx.fillRect(18 + rightHandOffset, 6, 2, 4);
            ctx.fillRect(20 + rightHandOffset, 6, 2, 4);
        }
        
        function renderMinimap() {
            minimapCtx.clearRect(0, 0, 180, 180);
            
            const scale = 180 / MAP_SIZE;
            
            minimapCtx.fillStyle = '#90EE90';
            minimapCtx.fillRect(0, 0, 180, 180);
            
            // ì§‘ë“¤ í‘œì‹œ
            houses.forEach(house => {
                minimapCtx.fillStyle = '#4A4A4A';
                minimapCtx.fillRect(
                    house.x * scale, 
                    house.y * scale, 
                    house.width * scale, 
                    house.height * scale
                );
                
                // ì§‘ í…Œë‘ë¦¬
                minimapCtx.strokeStyle = '#5A5A5A';
                minimapCtx.lineWidth = 1;
                minimapCtx.strokeRect(
                    house.x * scale, 
                    house.y * scale, 
                    house.width * scale, 
                    house.height * scale
                );
            });
            
            // ìê¸°ì¥ í‘œì‹œ
            if (zone.isActive) {
                // ë‹¤ìŒ ìê¸°ì¥ (ì ì„ )
                if (zone.showNextZone) {
                    minimapCtx.strokeStyle = '#0088ff'; // ë°ì€ íŒŒë€ìƒ‰
                    minimapCtx.lineWidth = 2;
                    minimapCtx.setLineDash([3, 3]);
                    minimapCtx.beginPath();
                    minimapCtx.arc(zone.nextCenterX * scale, zone.nextCenterY * scale, zone.nextRadius * scale, 0, Math.PI * 2);
                    minimapCtx.stroke();
                    minimapCtx.setLineDash([]);
                    
                    // ë‹¤ìŒ ìê¸°ì¥ ì¤‘ì‹¬ì 
                    minimapCtx.fillStyle = '#0088ff';
                    minimapCtx.beginPath();
                    minimapCtx.arc(zone.nextCenterX * scale, zone.nextCenterY * scale, 1, 0, Math.PI * 2);
                    minimapCtx.fill();
                }
                
                // í˜„ì¬ ìê¸°ì¥ (ì‹¤ì„ )
                minimapCtx.strokeStyle = '#0066ff'; // íŒŒë€ìƒ‰
                minimapCtx.lineWidth = 2;
                minimapCtx.setLineDash([]);
                minimapCtx.beginPath();
                minimapCtx.arc(zone.centerX * scale, zone.centerY * scale, zone.currentRadius * scale, 0, Math.PI * 2);
                minimapCtx.stroke();
                
                // í˜„ì¬ ìê¸°ì¥ ì¤‘ì‹¬ì 
                minimapCtx.fillStyle = '#0066ff';
                minimapCtx.beginPath();
                minimapCtx.arc(zone.centerX * scale, zone.centerY * scale, 2, 0, Math.PI * 2);
                minimapCtx.fill();
            }
            
            // í”Œë ˆì´ì–´ë§Œ í‘œì‹œ (ì ë“¤ ì œê±°)
            minimapCtx.fillStyle = '#4444ff';
            minimapCtx.beginPath();
            minimapCtx.arc(player.x * scale, player.y * scale, 3, 0, Math.PI * 2);
            minimapCtx.fill();
        }
        
        function updateHUD() {
            document.getElementById('healthText').textContent = Math.max(0, Math.floor(player.health));
            document.getElementById('armorText').textContent = Math.max(0, Math.floor(player.armor));
            document.getElementById('healthFill').style.width = Math.max(0, player.health) + '%';
            document.getElementById('armorFill').style.width = Math.max(0, player.armor) + '%';
            document.getElementById('aliveCount').textContent = enemies.length + (player.health > 0 ? 1 : 0);
            
            // í˜„ì¬ ë¬´ê¸° í‘œì‹œ
            const currentWeaponElement = document.getElementById('currentWeapon');
            if (player.currentWeapon === 'grenade') {
                currentWeaponElement.textContent = `í˜„ì¬ ë¬´ê¸°: ğŸ§¨ ìˆ˜ë¥˜íƒ„ (${player.grenades}ê°œ)`;
            } else {
                const currentWeapon = player.weapons[player.currentWeapon];
                let weaponText = `í˜„ì¬ ë¬´ê¸°: ${currentWeapon.name}`;
                if (currentWeapon.ammo !== -1) {
                    weaponText += ` (${currentWeapon.ammo}/${currentWeapon.maxAmmo})`;
                }
                currentWeaponElement.textContent = weaponText;
            }
            
            // ë°©ì–´êµ¬ ë ˆë²¨ í‘œì‹œ
            const armorLevelElement = document.getElementById('armorLevel');
            if (player.armorLevel > 0) {
                const levelColors = { 1: '#C0C0C0', 2: '#808080', 3: '#2F2F2F' };
                const maxArmor = player.armorLevel === 1 ? 30 : player.armorLevel === 2 ? 60 : 100;
                const durabilityPercent = Math.floor((player.armor / maxArmor) * 100);
                armorLevelElement.innerHTML = `<span style="color: ${levelColors[player.armorLevel]};">[Lv.${player.armorLevel} ${durabilityPercent}%]</span>`;
            } else {
                armorLevelElement.textContent = '';
            }
            
            // ì¸ë²¤í† ë¦¬ ì •ë³´ ì—…ë°ì´íŠ¸
            const inventoryInfo = document.getElementById('inventoryDisplay');
            let inventoryDisplay = '<div style="font-size: 16px; margin-bottom: 10px; color: #ffff00;">ë³´ìœ  ì•„ì´í…œ</div>';
            
            // ìˆ˜ë¥˜íƒ„
            if (player.grenades > 0) {
                inventoryDisplay += `<div style="font-size: 14px;">ğŸ§¨ ìˆ˜ë¥˜íƒ„: ${player.grenades}ê°œ</div>`;
            }
            
            // ë°©ì–´êµ¬ ì •ë³´
            if (player.armorLevel > 0) {
                const levelNames = { 1: '1ë ˆë²¨ ë°©ì–´êµ¬', 2: '2ë ˆë²¨ ë°©ì–´êµ¬', 3: '3ë ˆë²¨ ë°©ì–´êµ¬' };
                const levelColors = { 1: '#C0C0C0', 2: '#808080', 3: '#2F2F2F' };
                inventoryDisplay += `<div style="font-size: 14px; color: ${levelColors[player.armorLevel]};">ğŸ›¡ï¸ ${levelNames[player.armorLevel]}</div>`;
            }
            
            // ë¬´ê¸° ìŠ¬ë¡¯
            const weaponKeys = Object.keys(player.weapons);
            inventoryDisplay += `<div style="font-size: 12px; margin-top: 10px; line-height: 1.3;">`;
            
            const fistActive = player.currentWeapon === 'fist';
            inventoryDisplay += `<div style="color: ${fistActive ? '#ffff00' : '#ffffff'}">X: ğŸ‘Š ì£¼ë¨¹</div>`;
            
            const otherWeapons = weaponKeys.filter(key => key !== 'fist');
            for (let i = 0; i < 2; i++) {
                const slotNum = i + 1;
                if (i < otherWeapons.length) {
                    const weaponKey = otherWeapons[i];
                    const weapon = player.weapons[weaponKey];
                    const isActive = weaponKey === player.currentWeapon;
                    
                    // íƒ„ì•½ì´ ì—†ìœ¼ë©´ íšŒìƒ‰ìœ¼ë¡œ í‘œì‹œ
                    let weaponColor = '#ffffff';
                    if (isActive) {
                        weaponColor = '#ffff00';
                    } else if (weapon.ammo <= 0 && weapon.ammo !== -1) {
                        weaponColor = '#666666'; // íƒ„ì•½ ì—†ìŒ
                    }
                    
                    inventoryDisplay += `<div style="color: ${weaponColor}">
                        ${slotNum}: ${weapon.name} ${weapon.ammo <= 0 && weapon.ammo !== -1 ? '(íƒ„ì•½ ì—†ìŒ)' : ''}
                    </div>`;
                } else {
                    inventoryDisplay += `<div style="color: #666666">${slotNum}: ë¹ˆ ìŠ¬ë¡¯</div>`;
                }
            }
            
            const grenadeActive = player.currentWeapon === 'grenade';
            if (player.grenades > 0) {
                inventoryDisplay += `<div style="color: ${grenadeActive ? '#ffff00' : '#ffffff'}">3: ğŸ§¨ ìˆ˜ë¥˜íƒ„ (${player.grenades})</div>`;
            } else {
                inventoryDisplay += `<div style="color: #666666">3: ğŸ§¨ ìˆ˜ë¥˜íƒ„ (0)</div>`;
            }
            
            inventoryDisplay += `</div>`;
            inventoryInfo.innerHTML = inventoryDisplay;
            
            // êµ¬ë¥´ê¸° ì¿¨íƒ€ì„ ì—…ë°ì´íŠ¸
            const now = Date.now();
            const timeSinceLastDash = now - player.lastDashTime;
            const cooldownRemaining = Math.max(0, player.dashCooldown - timeSinceLastDash);
            const cooldownPercent = Math.max(0, (player.dashCooldown - cooldownRemaining) / player.dashCooldown * 100);
            
            const dashCooldownFill = document.getElementById('dashCooldownFill');
            const dashCooldownSection = document.getElementById('dashCooldownSection');
            
            if (cooldownRemaining > 0) {
                dashCooldownFill.style.width = cooldownPercent + '%';
                dashCooldownFill.style.background = 'linear-gradient(90deg, #ff4444, #ff8888)'; // ë¹¨ê°„ìƒ‰ (ì¿¨íƒ€ì„ ì¤‘)
                dashCooldownSection.style.opacity = '1';
            } else {
                dashCooldownFill.style.width = '100%';
                dashCooldownFill.style.background = 'linear-gradient(90deg, #00ff00, #88ff88)'; // ì´ˆë¡ìƒ‰ (ì‚¬ìš© ê°€ëŠ¥)
                dashCooldownSection.style.opacity = '0.7';
            }
            
            // íƒ„ì•½ í˜„í™© ì—…ë°ì´íŠ¸
            const ammoTable = document.getElementById('ammoTable');
            let ammoDisplay = '<table style="width: 100%; border-collapse: collapse;">';
            
            // íƒ„ì•½ íƒ€ì…ë³„ ì •ë³´
            const ammoTypes = [
                { type: 'rifle', name: 'AR', color: '#000000', icon: 'ğŸ”«' },
                { type: 'shotgun', name: 'ìƒ·ê±´', color: '#8B4513', icon: 'ğŸ”«' },
                { type: 'smg', name: 'SMG', color: '#00CED1', icon: 'ğŸ”«' },
                { type: 'sniper', name: 'SR', color: '#D3D3D3', icon: 'ğŸ”«' }
            ];
            
            ammoTypes.forEach(ammoType => {
                // ì¸ë²¤í† ë¦¬ì˜ íƒ„ì•½ ìˆ˜ëŸ‰
                const inventoryAmmo = player.ammoInventory[ammoType.type] || 0;
                
                // í•´ë‹¹ íƒ„ì•½ íƒ€ì…ì„ ì‚¬ìš©í•˜ëŠ” ë¬´ê¸°ë“¤ì˜ í˜„ì¬ ì¥ì „ëœ íƒ„ì•½ê³¼ ìµœëŒ€ íƒ„ì•½ ê³„ì‚°
                let currentAmmo = 0;
                let maxAmmo = 0;
                let hasWeapon = false;
                
                Object.keys(player.weapons).forEach(weaponKey => {
                    const weapon = player.weapons[weaponKey];
                    const originalWeapon = weapons[weaponKey];
                    if (originalWeapon && originalWeapon.ammoType === ammoType.type) {
                        currentAmmo += weapon.ammo;
                        maxAmmo += weapon.maxAmmo;
                        hasWeapon = true;
                    }
                });
                
                // í‘œ í–‰ ìƒì„±
                const hasAmmo = inventoryAmmo > 0 || currentAmmo > 0;
                const opacity = hasWeapon && hasAmmo ? '1.0' : '0.5';
                const textColor = hasWeapon && hasAmmo ? ammoType.color : '#666666';
                
                ammoDisplay += `
                    <tr style="opacity: ${opacity};">
                        <td style="padding: 2px 5px; color: ${textColor}; font-weight: bold;">${ammoType.name}</td>
                        <td style="padding: 2px 5px; text-align: right; color: ${hasAmmo ? '#ffffff' : '#666666'};">${currentAmmo}</td>
                        <td style="padding: 2px 5px; color: #888888;">+</td>
                        <td style="padding: 2px 5px; text-align: left; color: ${inventoryAmmo > 0 ? '#00ff00' : '#666666'};">${inventoryAmmo}</td>
                    </tr>
                `;
            });
            
            ammoDisplay += '</table>';
            ammoTable.innerHTML = ammoDisplay;
        }
        
        function gameLoop() {
            update();
            render();
            requestAnimationFrame(gameLoop);
        }
        
        // ìê¸°ì¥ ì—…ë°ì´íŠ¸ í•¨ìˆ˜
        function updateZone() {
            const now = Date.now();
            
            // ìê¸°ì¥ í™œì„±í™” ì²´í¬
            if (!zone.isActive && now >= zone.activationTime) {
                zone.isActive = true;
            }
            
            if (!zone.isActive) return;
            
            // ì¶•ì†Œ ì‹œì‘ ì²´í¬
            if (!zone.isShrinking && now >= zone.shrinkStartTime) {
                startZoneShrink();
            }
            
            // ì¶•ì†Œ ì¤‘ ì²˜ë¦¬
            if (zone.isShrinking) {
                const elapsed = now - zone.shrinkStartTime;
                const progress = Math.min(elapsed / zone.shrinkDuration, 1);
                
                zone.currentRadius = zone.startRadius - (zone.startRadius - zone.targetRadius) * progress;
                
                if (progress >= 1) {
                    zone.isShrinking = false;
                    zone.phase++;
                    
                    if (zone.phase < zone.maxPhases) {
                        // ë‹¤ìŒ ì¶•ì†Œ ì¤€ë¹„ - ë‹¨ê³„ë³„ë¡œ ëŒ€ê¸° ì‹œê°„ ë‹¨ì¶•
                        const baseWaitTime = 45000; // ê¸°ë³¸ 45ì´ˆ
                        const waitReduction = zone.phase * 8000; // ê° ë‹¨ê³„ë§ˆë‹¤ 8ì´ˆì”© ë‹¨ì¶•
                        const nextWaitTime = Math.max(15000, baseWaitTime - waitReduction); // ìµœì†Œ 15ì´ˆ
                        
                        zone.shrinkStartTime = now + nextWaitTime;
                        zone.damagePerSecond += 2; // ë°ë¯¸ì§€ ì¦ê°€
                    }
                }
            }
            
            // ìê¸°ì¥ ë°– ë°ë¯¸ì§€ ì²˜ë¦¬
            checkZoneDamage();
        }
        
        // ìê¸°ì¥ ì¶•ì†Œ ì‹œì‘
        function startZoneShrink() {
            zone.isShrinking = true;
            zone.startRadius = zone.currentRadius;
            
            // ë‹¤ìŒ ìê¸°ì¥ ìœ„ì¹˜ë¡œ ì´ë™
            zone.centerX = zone.nextCenterX;
            zone.centerY = zone.nextCenterY;
            zone.targetRadius = zone.nextRadius;
            
            // ë‹¨ê³„ë³„ë¡œ ì¶•ì†Œ ì†ë„ ì¦ê°€ (í›„ë°˜ìœ¼ë¡œ ê°ˆìˆ˜ë¡ ë¹¨ë¼ì§)
            const baseDuration = 30000; // ê¸°ë³¸ 30ì´ˆ
            const speedMultiplier = Math.max(0.3, 1 - (zone.phase * 0.15)); // ê° ë‹¨ê³„ë§ˆë‹¤ 15%ì”© ë¹¨ë¼ì§
            zone.shrinkDuration = Math.floor(baseDuration * speedMultiplier);
            
            // ë‹¤ìŒ ë‹¤ìŒ ìê¸°ì¥ ìœ„ì¹˜ ë¯¸ë¦¬ ìƒì„±
            if (zone.phase + 1 < zone.maxPhases) {
                generateNextZone();
            } else {
                zone.showNextZone = false;
            }
        }
        
        // ìê¸°ì¥ ë°ë¯¸ì§€ ì²´í¬
        function checkZoneDamage() {
            const now = Date.now();
            const damageIndicator = document.getElementById('damageIndicator');
            
            // í”Œë ˆì´ì–´ ìê¸°ì¥ ë°ë¯¸ì§€
            const playerDist = Math.sqrt((player.x - zone.centerX) ** 2 + (player.y - zone.centerY) ** 2);
            if (playerDist > zone.currentRadius) {
                // ìê¸°ì¥ ë°–ì— ìˆì„ ë•Œ í™”ë©´ í…Œë‘ë¦¬ ê²½ê³ 
                damageIndicator.classList.add('zone-warning');
                
                if (now - zone.lastDamageTime >= 1000) {
                    const isDead = takeDamage(player, zone.damagePerSecond, true); // ìê¸°ì¥ ë°ë¯¸ì§€ í”Œë˜ê·¸
                    if (isDead) {
                        gameState = 'gameOver';
                    }
                    zone.lastDamageTime = now;
                }
            } else {
                // ìê¸°ì¥ ì•ˆì— ìˆì„ ë•Œ ê²½ê³  ì œê±°
                damageIndicator.classList.remove('zone-warning');
            }
            
            // ì ë“¤ ìê¸°ì¥ ë°ë¯¸ì§€
            for (let i = enemies.length - 1; i >= 0; i--) {
                const enemy = enemies[i];
                const enemyDist = Math.sqrt((enemy.x - zone.centerX) ** 2 + (enemy.y - zone.centerY) ** 2);
                
                if (enemyDist > zone.currentRadius) {
                    if (now - (enemy.lastZoneDamage || 0) >= 1000) {
                        const isDead = takeDamage(enemy, zone.damagePerSecond, true); // ìê¸°ì¥ ë°ë¯¸ì§€ í”Œë˜ê·¸
                        if (isDead) {
                            enemies.splice(i, 1);
                        }
                        enemy.lastZoneDamage = now;
                    }
                }
            }
        }
    </script>
    <script>
        // ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆë“¤
        document.addEventListener('keydown', (e) => {
            // ë¸Œë¼ìš°ì € ì¤Œ ë‹¨ì¶•í‚¤ ë°©ì§€
            if ((e.ctrlKey || e.metaKey) && (e.key === '+' || e.key === '-' || e.key === '=' || e.key === '0')) {
                e.preventDefault();
                return false;
            }
            
            keys[e.key.toLowerCase()] = true;
            
            // ìŠ¤í˜ì´ìŠ¤ë°”ë¡œ êµ¬ë¥´ê¸°
            if (e.key === ' ') {
                e.preventDefault();
                startDash();
            }
            
            if (e.key === 'r' || e.key === 'R') {
                // êµ¬ë¥´ê¸° ì¤‘ì´ë‚˜ ì´ë¯¸ ì¬ì¥ì „ ì¤‘ì—ëŠ” ì¬ì¥ì „ ë¶ˆê°€
                if (!player.isDashing && !player.isReloading && player.currentWeapon !== 'fist' && player.currentWeapon !== 'grenade') {
                    startReload(player.currentWeapon);
                }
            }
            
            if (e.key === 'f' || e.key === 'F') {
                // êµ¬ë¥´ê¸° ì¤‘ì—ëŠ” ì•„ì´í…œ íšë“ ë¶ˆê°€
                if (!player.isDashing) {
                    items.forEach((item, index) => {
                    if (distance(player, item) < 30) {
                        if (item.type === 'weapon') {
                            const weaponType = item.data.weaponType;
                            const weaponKeys = Object.keys(player.weapons).filter(key => key !== 'fist');
                            
                            if (weaponKeys.length < 2) {
                                // ë¹ˆ ìŠ¬ë¡¯ì´ ìˆìœ¼ë©´ ì¶”ê°€
                                const weaponData = { ...weapons[weaponType] };
                                player.weapons[weaponType] = weaponData;
                                player.currentWeapon = weaponType;
                            } else {
                                // ì¸ë²¤í† ë¦¬ê°€ ê°€ë“ ì°¼ì„ ë•Œ í˜„ì¬ ë¬´ê¸°ë¥¼ ë“œë¡­í•˜ê³  ìƒˆ ë¬´ê¸°ë¡œ êµì²´
                                if (player.currentWeapon !== 'fist' && player.currentWeapon !== 'grenade') {
                                    items.push({
                                        x: player.x + (Math.random() - 0.5) * 30,
                                        y: player.y + (Math.random() - 0.5) * 30,
                                        type: 'weapon',
                                        data: { weaponType: player.currentWeapon },
                                        ...itemTypes.weapon
                                    });
                                    delete player.weapons[player.currentWeapon];
                                }
                                
                                const weaponData = { ...weapons[weaponType] };
                                player.weapons[weaponType] = weaponData;
                                player.currentWeapon = weaponType;
                            }
                        } else if (item.type.startsWith('armor')) {
                            // ê¸°ì¡´ ë°©ì–´êµ¬ ë“œë¡­ (ë ˆë²¨ì´ ìˆì„ ë•Œë§Œ)
                            if (player.armorLevel > 0) {
                                const oldArmorType = `armor${player.armorLevel}`;
                                const oldMaxArmor = player.armorLevel === 1 ? 30 : player.armorLevel === 2 ? 60 : 100;
                                items.push({
                                    x: player.x + (Math.random() - 0.5) * 30,
                                    y: player.y + (Math.random() - 0.5) * 30,
                                    type: oldArmorType,
                                    data: { 
                                        level: player.armorLevel, 
                                        maxArmor: oldMaxArmor,
                                        currentArmor: player.armor // í˜„ì¬ ë‚´êµ¬ë„ë¡œ ë“œë¡­
                                    },
                                    ...itemTypes[oldArmorType]
                                });
                            }
                            
                            // ìƒˆ ë°©ì–´êµ¬ ì°©ìš©
                            player.armor = item.data.currentArmor || item.data.maxArmor; // ë“œë¡­ëœ ë°©ì–´êµ¬ë©´ í˜„ì¬ ë‚´êµ¬ë„, ìƒˆ ë°©ì–´êµ¬ë©´ ìµœëŒ€ê°’
                            player.armorLevel = item.data.level;
                        } else if (item.type === 'medkit') {
                            if (player.health < 100) {
                                player.health = Math.min(100, player.health + item.data.amount);
                            }
                        } else if (item.type === 'bandage') {
                            if (player.health < 75) {
                                player.health = Math.min(75, player.health + item.data.amount);
                            }
                        } else if (item.type === 'grenade') {
                            player.grenades = (player.grenades || 0) + item.data.amount;
                        } else if (item.type.startsWith('ammo_')) {
                            // íƒ„ì•½ì„ ì¸ë²¤í† ë¦¬ì— ì €ì¥
                            const ammoType = item.data.ammoType;
                            player.ammoInventory[ammoType] = (player.ammoInventory[ammoType] || 0) + item.data.amount;
                        }
                            
                            items.splice(index, 1);
                    }
                });
                }
            }
            
            // Xí‚¤ë¡œ ì£¼ë¨¹
            if (e.key === 'x' || e.key === 'X') {
                player.currentWeapon = 'fist';
            }
            
            // 1ë²ˆí‚¤ë¡œ ì²« ë²ˆì§¸ ë¬´ê¸°
            if (e.key === '1') {
                const weaponKeys = Object.keys(player.weapons).filter(key => key !== 'fist');
                if (weaponKeys.length > 0) {
                    const weapon = player.weapons[weaponKeys[0]];
                    // íƒ„ì•½ì´ ìˆê±°ë‚˜ ì£¼ë¨¹ì´ë©´ ì„ íƒ ê°€ëŠ¥
                    if (weapon.ammo > 0 || weapon.ammo === -1) {
                        player.currentWeapon = weaponKeys[0];
                    }
                }
            }
            
            // 2ë²ˆí‚¤ë¡œ ë‘ ë²ˆì§¸ ë¬´ê¸°
            if (e.key === '2') {
                const weaponKeys = Object.keys(player.weapons).filter(key => key !== 'fist');
                if (weaponKeys.length > 1) {
                    const weapon = player.weapons[weaponKeys[1]];
                    // íƒ„ì•½ì´ ìˆê±°ë‚˜ ì£¼ë¨¹ì´ë©´ ì„ íƒ ê°€ëŠ¥
                    if (weapon.ammo > 0 || weapon.ammo === -1) {
                        player.currentWeapon = weaponKeys[1];
                    }
                }
            }
            
            // 3ë²ˆí‚¤ë¡œ ìˆ˜ë¥˜íƒ„
            if (e.key === '3') {
                if (player.grenades > 0) {
                    player.currentWeapon = 'grenade';
                }
            }
            
            if (e.key === 'q' || e.key === 'Q') {
                if (player.currentWeapon !== 'fist' && player.currentWeapon !== 'grenade') {
                    items.push({
                        x: player.x + (Math.random() - 0.5) * 30,
                        y: player.y + (Math.random() - 0.5) * 30,
                        type: 'weapon',
                        data: { weaponType: player.currentWeapon },
                        ...itemTypes.weapon
                    });
                    
                    delete player.weapons[player.currentWeapon];
                    player.currentWeapon = 'fist';
                }
            }
            
            if (e.code === 'Space') {
                e.preventDefault();
                keys[' '] = true;
                
                // êµ¬ë¥´ê¸° ì¤‘ì´ë‚˜ ì¬ì¥ì „ ì¤‘ì—ëŠ” ê³µê²© ë¶ˆê°€
                if (!player.isDashing && !player.isReloading) {
                    if (player.currentWeapon === 'grenade') {
                        const worldMouseX = mouseX + camera.x;
                        const worldMouseY = mouseY + camera.y;
                        shoot(player, worldMouseX, worldMouseY);
                    } else {
                        const currentWeapon = player.weapons[player.currentWeapon];
                        if (currentWeapon && !currentWeapon.autoFire) {
                            const worldMouseX = mouseX + camera.x;
                            const worldMouseY = mouseY + camera.y;
                            shoot(player, worldMouseX, worldMouseY);
                        }
                    }
                }
            }
        });
        
        document.addEventListener('keyup', (e) => {
            keys[e.key.toLowerCase()] = false;
            
            if (e.code === 'Space') {
                keys[' '] = false;
            }
        });
        
        document.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            mouseX = e.clientX - rect.left;
            mouseY = e.clientY - rect.top;
        });
        
        document.addEventListener('mousedown', (e) => {
            if (e.button === 0) {
                // ì¬ì¥ì „ ì¤‘ì¼ ë•Œ ì¢Œí´ë¦­ìœ¼ë¡œ ì·¨ì†Œ
                if (player.isReloading) {
                    cancelReload();
                    return;
                }
                
                mousePressed = true;
                const worldMouseX = mouseX + camera.x;
                const worldMouseY = mouseY + camera.y;
                
                // êµ¬ë¥´ê¸° ì¤‘ì´ë‚˜ ì¬ì¥ì „ ì¤‘ì—ëŠ” ê³µê²© ë¶ˆê°€
                if (!player.isDashing && !player.isReloading) {
                    if (player.currentWeapon === 'grenade') {
                        shoot(player, worldMouseX, worldMouseY);
                    } else {
                        const currentWeapon = player.weapons[player.currentWeapon];
                        if (currentWeapon && !currentWeapon.autoFire) {
                            shoot(player, worldMouseX, worldMouseY);
                        }
                    }
                }
            }
        });
        
        document.addEventListener('mouseup', (e) => {
            if (e.button === 0) {
                mousePressed = false;
            }
        });
        
        // ì»¨í…ìŠ¤íŠ¸ ë©”ë‰´ ë¹„í™œì„±í™”
        document.addEventListener('contextmenu', (e) => {
            e.preventDefault();
        });
        
        // ë§ˆìš°ìŠ¤ íœ  ì¤Œ ë°©ì§€
        document.addEventListener('wheel', (e) => {
            if (e.ctrlKey || e.metaKey) {
                e.preventDefault();
                return false;
            }
        }, { passive: false });
        
        // í„°ì¹˜ ì¤Œ ë°©ì§€
        document.addEventListener('touchstart', (e) => {
            if (e.touches.length > 1) {
                e.preventDefault();
            }
        }, { passive: false });
        
        document.addEventListener('touchmove', (e) => {
            if (e.touches.length > 1) {
                e.preventDefault();
            }
        }, { passive: false });
        
        // í˜ì´ì§€ ì´íƒˆ ë°©ì§€
        window.addEventListener('beforeunload', (e) => {
            if (gameState === 'playing') {
                e.preventDefault();
                e.returnValue = '';
            }
        });
        
        // í¬ì»¤ìŠ¤ ìƒì„ ë•Œ í‚¤ ìƒíƒœ ì´ˆê¸°í™”
        window.addEventListener('blur', () => {
            keys = {};
            mousePressed = false;
        });
        
        // ì°½ í¬ê¸° ë³€ê²½ ì‹œ ìº”ë²„ìŠ¤ í¬ê¸° ì¡°ì •
        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        });
    </script>
</body>
</html>